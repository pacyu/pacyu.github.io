






[{"content":"","date":"2022-01-19","externalUrl":null,"permalink":"/categories/algorithms/","section":"Categories","summary":"","title":"Algorithms","type":"categories"},{"content":"","date":"2022-01-19","externalUrl":null,"permalink":"/tags/codewars/","section":"Tags","summary":"","title":"Codewars","type":"tags"},{"content":"","date":"2022-01-19","externalUrl":null,"permalink":"/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":"","date":"2022-01-19","externalUrl":null,"permalink":"/tags/haskell/","section":"Tags","summary":"","title":"Haskell","type":"tags"},{"content":"实际上这是Codewars的一个题，但没能完全通过。\n先放代码：\nmodule LambdaTermReduction (lambda,free,bound,reduce) where import Data.List (nub) -- | For example: -- | Lam \u0026#34;λ\u0026#34; -- | App \u0026#34;@\u0026#34; -- | (λx.x) @ y ==\u0026gt; x x λ y @ -- | (λx.λx.x @ x) @ y ==\u0026gt; x x x x @ λ λ y @ -- | ((λx.λy.λz.((x @ z) @ (y @ z))) @ (λx.λ_.x)) @ (λz.z) -- | = (λy.λz.((λx.λ_.x @ z) @ (y @ z))) @ (λz.z) -- | = (λy.λz.((λ_.z) @ (y @ z))) @ (λz.z) -- | = (λy.λz.z) @ (λz.z) -- | = λz.z data Lambda = App Lambda Lambda | Lam String Lambda | Body Lambda | T String | F String deriving (Eq) instance Show (Lambda) where show (App a b) = show a ++ \u0026#34; \u0026#34; ++ show b ++ \u0026#34; @\u0026#34; show (Lam a b) = a ++ \u0026#34; \u0026#34; ++ show b ++ \u0026#34; λ\u0026#34; show (Body a) = show a show (T a) = a show (F a) = a prefixPrint :: Lambda -\u0026gt; String prefixPrint (App a b) = \u0026#34;App (\u0026#34; ++ prefixPrint a ++ \u0026#34;) (\u0026#34; ++ prefixPrint b ++ \u0026#34;)\u0026#34; prefixPrint (Lam a b) = \u0026#34;Lam \u0026#34; ++ a ++ \u0026#34; (\u0026#34; ++ prefixPrint b ++ \u0026#34;)\u0026#34; prefixPrint (Body a) = \u0026#34;Body (\u0026#34; ++ prefixPrint a ++ \u0026#34;)\u0026#34; prefixPrint (T a) = \u0026#34;T \u0026#34; ++ a prefixPrint (F a) = \u0026#34;F \u0026#34; ++ a untypedLambdaExpress :: Lambda -\u0026gt; String untypedLambdaExpress (App a b) = \u0026#34;(\u0026#34; ++ untypedLambdaExpress a ++ \u0026#34; \u0026#34; ++ untypedLambdaExpress b ++ \u0026#34;)\u0026#34; untypedLambdaExpress (Lam a (Body b)) = \u0026#34;Lam \u0026#34; ++ a ++ \u0026#34;.\u0026#34; ++ untypedLambdaExpress b untypedLambdaExpress (T a) = a untypedLambdaExpress (F a) = a isBound :: Lambda -\u0026gt; Bool isBound (T _) = True isBound _ = False isFree :: Lambda -\u0026gt; Bool isFree (F _) = True isFree _ = False variable :: Lambda -\u0026gt; String -\u0026gt; Lambda variable (App a b) s = App (variable a s) (variable b s) variable (Lam a b) s = Lam a (variable b s) variable (Body a) s = Body (variable a s) variable (F a) s = if s == a then T a else F a variable a s = a parser :: [Lambda] -\u0026gt; String -\u0026gt; String -\u0026gt; Lambda parser [a] _ [] = a parser _ _ [] = error \u0026#34;Syntax error have occurred.\u0026#34; parser a b (c:s) | c == \u0026#39; \u0026#39; = parser a \u0026#34;\u0026#34; s | c == \u0026#39;λ\u0026#39; = parser ((Lam (show nxt) (Body (variable top (show nxt)))):pop2 a) \u0026#34;\u0026#34; s | c == \u0026#39;@\u0026#39; = parser ((App nxt top):pop2 a) \u0026#34;\u0026#34; s | otherwise = if s /= [] \u0026amp;\u0026amp; head s /= \u0026#39; \u0026#39; then parser a (b++[c]) s else parser (F (b++[c]):a) \u0026#34;\u0026#34; s where top = head a nxt = head $ tail a pop2 = tail . tail lambda :: String -\u0026gt; Lambda lambda = parser [] \u0026#34;\u0026#34; free :: Lambda -\u0026gt; [String] free (App a b) = nub $ free a ++ free b free (Lam a b) = nub $ free b free (Body a) = nub $ free a free (F a) = [a] free _ = [] bound :: Lambda -\u0026gt; [String] bound (App a b) = nub $ bound a ++ bound b bound (Lam a b) = nub a: bound b bound (Body a) = nub $ bound a bound (T a) = [a] bound _ = [] app :: String -\u0026gt; Lambda -\u0026gt; Lambda -\u0026gt; Lambda app var (Lam a (Body b)) lam = if a == var then Lam a $ Body (app \u0026#34;\u0026#34; b lam) else Lam a $ Body (app var b lam) app var exp@(App a b) lam = if exp == apped then exp else reduce $ apped where apped = App (app var a lam) (app var b lam) app var (T a) lam | a == var = lam | otherwise = (T a) app var a _ = a reduce :: Lambda -\u0026gt; Lambda reduce (App (Lam a (Body b)) lam) = app a b lam reduce exp@(App (App a b) lam) = if exp == apped then exp else reduce $ apped where apped = App (reduce (App a b)) lam reduce (Lam a (Body b)) = Lam a $ reduce b reduce a = a ","date":"2022-01-19","externalUrl":null,"permalink":"/docs/2022-01-19-implement-a-simple-lambda-calculus-evaluator/","section":"Docs","summary":"","title":"Haskell 中实现一个简易的lambda 演算解释器","type":"docs"},{"content":"","date":"2022-01-19","externalUrl":null,"permalink":"/tags/math/","section":"Tags","summary":"","title":"Math","type":"tags"},{"content":"","date":"2022-01-19","externalUrl":null,"permalink":"/categories/mathematical/","section":"Categories","summary":"","title":"Mathematical","type":"categories"},{"content":"首先，我不得不歌颂下伟大的数学家们（包含哲学家、逻辑学家们）的智慧，他们兼具洞察力与创造力。\n嘛，有时候我觉得数学有点像分类学，数学基础大厦是不可能改变的，只是数学家们从不同角度重新对知识梳理一遍后，让我们又从新的角度去理解了一遍数学，这往往是令人兴奋的。\n在对证明还没有任何概念的时候，我学习了数分，之后便想抱起人们常说的很难的课程《实分析》看，现在看来，会觉得「难」是显然的，当然实分析也不仅仅是证明部分难，也涉及到对实数域上很多性质的理解。但真正理解什么是「证明」绝对是十分重要、有帮助的，这意味着对基础概念有了很多基础性知识和扩展性知识的了解和意识。这方面来说，要看懂《抽象代数》也是一样的，或者说，如果不懂「证明」，我更认为先看《抽代》反而更合适（相对于学《实分析》），至少有可能能让你开始意识到某种形式的重要性，或者某种思维方式的重要性，而如果对这块感兴趣，就可以更深入的去学习集合论、数理逻辑的内容。\n虽然这么说，然而，我却是在用了一些定理证明助手（Coq/Agda）后，才真正开始有了「证明」的意识，所以，我想说数学家们的脑袋实在太过于聪明。\n「证明」在学《实分析》以前的数学体现确实不算是非常明显（包括《数分》，当然不排除有的人已经掌握了这种思维习惯），以至于大部分人（以及我）在学到这个位置时仅仅学会了计算和记忆概念（我想或许是这样，也可能只有我是这样），但回忆起来，高中数学的一些题已经多次强调和在训练我们对「证明」的意识，比如数列、不等式等等。。。但还是对其概念模模糊糊。那时候啊，我觉得什么归纳法、反证法看起来就像废话一样（捂脸），不理解这种证明的意义是啥，没感觉像是证明，更喜欢计算题，算就完事了。多次错过了意识到它的技术原理的魅力，不过呢，好巧不巧，后来是计算机科学 -\u0026gt; 数理逻辑让我入了证明的门，重新开始对这些东西有了新的理解。\n集合论、证明论、模型论、递归论等等数理逻辑的内容过于庞大，虽然有一些交叉知识，但一两句话依然是讲不完的，从罗素悖论到公理化系统建立，从 ZF 到 ZFC，从希尔伯特计划到哥德尔的断言，从丘奇、图灵等人对计算的描述到整个计算机科学的发展，从形式主义到构建/直觉主义，从证明到程序，从 Typed lambda calculus 到证明系统，从20世纪到现在，那个时代还没有编程语言，准确的说是编程语言的产物（lambda calculus就是一个最小化计算语言，而产物指现在我们用的编程语言工具），数学家、逻辑学家们仅凭借思考、智慧发现了这些东西，让我实在是佩服得不行。\n再次，我不得不歌颂下伟大的数学家们的智慧，潜藏在他们思维中那令人惊叹的洞察力与创造力，蕴含着某种深邃的思想。\n","date":"2021-08-18","externalUrl":null,"permalink":"/docs/2021-08-18-mathematicians-and-proofs/","section":"Docs","summary":"","title":"数学家与证明","type":"docs"},{"content":"","date":"2021-08-08","externalUrl":null,"permalink":"/tags/coq/","section":"Tags","summary":"","title":"Coq","type":"tags"},{"content":"\r一开始是想形式化几何不等式（均值不等式），然后想用来证明一些简单的不等式问题玩下，但发现直接证明 \\( a + b \\ge 2\\sqrt{a b} \\) 太难，没想到好办法，应该是我太菜。。。于是选择证明 \\( \\sqrt{(a + b)^2} \\ge \\sqrt{4ab} \\longrightarrow a + b \\ge 2\\sqrt{a b} \\) 的情形。\nFrom Coq.Reals Require Import Reals RIneq R_sqrt. Lemma rdiv_r: forall r, (r \u0026lt;\u0026gt; 0 -\u0026gt; r / r = r * / r)%R. Proof. intros. auto. Qed. Lemma two_pow2_eq_4: (2 ^ 2 = 4)%R. Proof. simpl. rewrite \u0026lt;- Rmult_comm. rewrite Rmult_assoc. rewrite Rmult_1_l. auto. Qed. Lemma two_eq_sqrt_4 : (2 = sqrt 4)%R. Proof. rewrite \u0026lt;- two_pow2_eq_4. rewrite sqrt_pow2. - reflexivity. - intuition. Qed. Theorem ineq_arith_means: forall a b, (0 \u0026lt;= a -\u0026gt; 0 \u0026lt;= b -\u0026gt; sqrt (4 * a * b) \u0026lt;= sqrt ((a + b)^2) -\u0026gt; 2 * sqrt(a * b) \u0026lt;= a + b)%R. Proof. intros a b H1 H2 H3. rewrite \u0026lt;- sqrt_pow2 with (a + b)%R. rewrite \u0026lt;- sqrt_pow2 with (2 * sqrt (a * b))%R. rewrite Rpow_mult_distr. rewrite pow2_sqrt. rewrite two_pow2_eq_4. * rewrite \u0026lt;- Rmult_assoc. assumption. * apply Rmult_le_pos. auto. auto. * rewrite two_eq_sqrt_4. rewrite \u0026lt;- sqrt_mult. apply sqrt_positivity. + apply Rmult_le_pos. - intuition. - apply Rmult_le_pos. auto. auto. + intuition. + apply Rmult_le_pos. auto. auto. * apply Rplus_le_le_0_compat. auto. auto. Qed. ","date":"2021-08-08","externalUrl":null,"permalink":"/docs/2021-08-08-to-prove-geometry-inequality-means-with-coq-/","section":"Docs","summary":"","title":"Coq 证明几何不等式","type":"docs"},{"content":"","date":"2020-11-04","externalUrl":null,"permalink":"/tags/c/c++/","section":"Tags","summary":"","title":"C/C++","type":"tags"},{"content":"\r介绍一种对数时间复杂度的斐波那契数列算法。\n指数时间 #\r我们都知道 Fibonacci 数平凡的树形递归算法时间复杂度是 \\( O(1.618^{n}) \\)，其证明很简单（参考\rwikipeida-Fibonacci： 利用矩阵形式：\n$$ \\begin{pmatrix} F_{i+2} \\\\ F_{i+1} \\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix}\\begin{pmatrix} F_{i+1} \\\\ F_{i} \\end{pmatrix} $$\n这里简写为 \\( \\vec{F_{i+1}} = \\mathbf{A}\\vec{F_{i}} \\)，将其递归累乘得到 \\( \\vec{F_{n}} = \\mathbf{A}^n\\vec{F_{0}} \\)。\n其中矩阵 \\( \\mathbf{A} \\) 的特征方程为 \\( \\lambda^2 - \\lambda - 1 = 0 \\)，特征值 \\( \\phi = \\frac{1 + \\sqrt{5}}{2} \\) 和 \\( -\\phi^{-1} = \\frac{1 - \\sqrt{5}}{2} \\) 对应的特征向量分别为 \\( \\vec{\\mu} = \\begin{pmatrix} \\phi \\\\ 1 \\end{pmatrix} \\) 和 \\( \\vec{\\nu} = \\begin{pmatrix} -\\phi^{-1}\\\\ 1 \\end{pmatrix} \\)，\n初始值 \\( \\vec{F_{0}} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{1}{\\sqrt{5}}(\\vec{\\mu} - \\vec{\\nu}) \\)，\n所以\n$$ \\begin{aligned} \\vec{F_{n}} \u0026amp;= \\frac{1}{\\sqrt{5}}(\\mathbf{A}^n\\vec{\\mu} - \\mathbf{A}^n\\vec{\\nu}) \\\\ \u0026amp;= \\frac{1}{\\sqrt{5}}(\\phi^n\\vec{\\mu} - (-\\phi)^{-n}\\vec{\\nu}) \\\\ \u0026amp;= \\frac{1}{\\sqrt{5}}(\\frac{1 + \\sqrt{5}}{2})^n\\begin{pmatrix} \\phi \\\\ 1 \\end{pmatrix} - \\frac{1}{\\sqrt{5}}(\\frac{1 - \\sqrt{5}}{2})^n\\begin{pmatrix} -\\phi^{-1} \\\\ 1 \\end{pmatrix} \\end{aligned} $$\n即得到 Fibonacci 的通项公式为：\n$$ \\begin{aligned} F_{n} \u0026amp;= \\frac{1}{\\sqrt{5}}(\\frac{1 + \\sqrt{5}}{2})^n - \\frac{1}{\\sqrt{5}}(\\frac{1 - \\sqrt{5}}{2})^n \\end{aligned} $$\n现在可以解释之所以该算法时间复杂度是 \\( O(1.618^{n}) \\)，是因为 \\( \\vec{F_{n}} = \\mathbf{A}^n\\vec{F_{0}} = O(\\mathbf{A}^n) = O(-\\phi^{-n}) = O(1.618^{n}) \\)。\n算法 Lisp 实现：\n(define (fib n) (cond ((= n 0) 1)) ((= n 1) 1)) (else (+ (fib (- n 2)) (fib (- n 1)))) 线性时间 #\r该算法考虑如下变换规则\\( T: a\\leftarrow a + b, b \\leftarrow a \\)，初始时 \\( a=1, b=0 \\)。\n这是一种带记忆搜索的迭代算法，它的证明很显然，所以仅给出算法实现。\n算法 Lisp 实现：\n(define (fib n) (define (fib-iter a b n) (if (= n 0) b (fib-iter (+ a b) a (- n 1)))) (fib-iter 1 0 n)) 对数时间 #\r该算法特别巧妙的地方是它在线性迭代的变换规则基础上做了一些改动，考虑变换规则\n$$ T_{pq}:\\begin{aligned} a \u0026amp;\\leftarrow bq + aq + ap \\\\ b \u0026amp;\\leftarrow bp + aq \\end{aligned} $$\n初始时 \\( a=1, b=0, p=0, q=1 \\)，如果我们能证明应用两次 \\( T_{pq} \\) 变换等效于使用一次同样形式的变换 \\( T_{p\u0026rsquo;q\u0026rsquo;} \\)，其中 \\( p\u0026rsquo;, q\u0026rsquo; \\) 可以通过 \\( p, q \\) 计算出来，那么我们就找到了一种求出这种变换的平方的方法，所以下面我将证明，应用两次变换 \\( T_{pq} \\) 我们可以得到一个固定模式。\n首先写出应用一次 \\( T_{pq} \\) 变换后的形式：\n$$ \\begin{aligned} a \u0026amp;\\leftarrow bq + aq + ap \\\\ b \u0026amp;\\leftarrow bp + aq \\end{aligned} \\overset{First}{\\Rightarrow} \\begin{aligned} a \u0026amp;\\leftarrow (bp+aq)q + (bq+aq+ap)q + (bq+aq+ap)p \\\\ b \u0026amp;\\leftarrow (bp + aq)p+ (bq+aq+ap)q \\end{aligned} $$\n我们展开上面的所有括号，并按初始形式重新写出式子以观察\n$$ \\begin{aligned} a \u0026amp;\\leftarrow bpq + aq^2 + bq^2 + aq^2 + apq + bpq + apq + ap^2 \\\\ b \u0026amp;\\leftarrow bp^2 + apq + bq^2 + apq + bq^2 + aq^2+apq \\end{aligned} \\rightarrow \\begin{aligned} a \u0026amp;\\leftarrow b(2pq + q^2) + a(2pq + q^2) + a(p^2+q^2) \\\\ b \u0026amp;\\leftarrow b(p^2+q^2) + a(2pq + q^2) \\end{aligned} $$\n令 \\( p = p^2+q^2, q = 2pq + q^2 \\)，有\n$$ \\begin{aligned} a \u0026amp;\\leftarrow bq + aq + ap \\\\ b \u0026amp;\\leftarrow bp + aq \\end{aligned} $$\n然后我们在此基础上应用第二次变换会发现依然还是可以写出同样的形式：\n$$ \\begin{aligned} a \u0026amp;\\leftarrow b(2pq + q^2) + a(2pq + q^2) + a(p^2+q^2) \\\\ b \u0026amp;\\leftarrow b(p^2+q^2) + a(2pq + q^2) \\end{aligned} \\overset{Second}{\\Rightarrow} \\begin{aligned} a \u0026amp;\\leftarrow {b(p^2+q^2) + a(2pq + q^2)}(2pq + q^2) + {b(2pq + q^2) + a(2pq + q^2) + a(p^2+q^2)}(2pq + q^2) + {b(2pq + q^2) + a(2pq + q^2) + a(p^2+q^2)}(p^2+q^2) \\\\ b \u0026amp;\\leftarrow {b(p^2+q^2) + a(2pq + q^2)}(p^2+q^2) + {b(2pq + q^2) + a(2pq + q^2) + a(p^2+q^2)}(2pq + q^2) \\end{aligned} \\\\ \\overset{p=p^2+q^2, q=2pq+q^2}{\\rightarrow} \\begin{aligned} a \u0026amp;\\leftarrow bq + aq + ap \\\\ b \u0026amp;\\leftarrow bp + aq \\end{aligned} \\overset{Second}{\\Rightarrow} \\begin{aligned} a \u0026amp;\\leftarrow (bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p \\\\ b \u0026amp;\\leftarrow (bp + aq)p + (bq + aq + ap)q \\end{aligned} = \\begin{aligned} a \u0026amp;\\leftarrow b(2pq + q^2) + a(2pq + q^2) + a(p^2+q^2) \\\\ b \u0026amp;\\leftarrow b(p^2+q^2) + a(2pq + q^2) \\end{aligned} $$\n于是我们得到算法：\n$$ \\begin{cases} \\left(\\begin{matrix} a \u0026amp;\\leftarrow a \\\\ b \u0026amp;\\leftarrow b \\\\ p \u0026amp;\\leftarrow p^2+q^2 \\\\ q \u0026amp;\\leftarrow 2pq + q^2 \\end{matrix}\\right. \u0026amp; \\text{ when x is even } \\\\ \\left(\\begin{matrix} a \u0026amp;\\leftarrow bq + aq + ap \\\\ b \u0026amp;\\leftarrow bp + aq \\\\ p \u0026amp;\\leftarrow p \\\\ q \u0026amp;\\leftarrow q \\end{matrix}\\right. \u0026amp; \\text{ when x is not even } \\end{cases} $$\n算法 Lisp 实现：\n(define (fib n) (define (fib-iter a b p q n) (cond ((= n 0) b) ((even? n) (fib-iter a b (+ (square p) (square q)) (+ (square q) (* 2 p q)) (/ n 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- n 1))))) (fib-iter 1 0 0 1 n)) 其实这是 SICP 第一章的一道练习题，证明不难，就是变量多可能有点绕，一开始心算有点打脑壳，然后草稿纸上写出来就很简单了。\n有關更多題解見我的github。\n","date":"2020-11-04","externalUrl":null,"permalink":"/docs/2020-11-04-fibpnacci-lgn/","section":"Docs","summary":"这是往主页中添加内容的例子。","title":"斐波那契数O(lgn)算法及证明","type":"docs"},{"content":"","date":"2020-11-01","externalUrl":null,"permalink":"/categories/fractal/","section":"Categories","summary":"","title":"Fractal","type":"categories"},{"content":"","date":"2020-11-01","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"\r前言 #\r话说一直想找时间写写关于学图形学时学到的东西，但又觉得码字好累（图形学中挺多公式和推导），这里先简单介绍一下如何使用 C/C++/Python 等语言画分形吧，其余的改天再补充。\n数学家们对分形的研究也有很长时间了，著名的 Mandelbrot set、Julia set、Newton\u0026rsquo;s fractal 等，嘛，水平有限，只能从程序方面欣赏她的美了。\n一些关于分形的网站：\rhttp://hpdz.net/\nMandelbrot set #\rC/C++：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;complex\u0026gt; using std::complex; uint8_t mandelbrot(complex\u0026lt;double\u0026gt; z, int max_iter) { complex\u0026lt;double\u0026gt; c = z; for (int k = 0; k \u0026lt; max_iter; k++) { if (std::abs(z) \u0026gt; 2.) return k; z = std::pow(z, 2.) + c; } return max_iter; } int main() { int w = 500, h = 500; double zoom_lx = -2., zoom_rx = 1., zoom_ly = -1.5, zoom_ry = 1.5; int max_iter = 1000; FILE* fp = fopen(\u0026#34;mandelbrot_frac_cpp.ppm\u0026#34;, \u0026#34;wb\u0026#34;); fprintf(fp, \u0026#34;P6 %d %d 255 \u0026#34;, w, h); for (int i = 0; i \u0026lt; h; i++) { double zy = zoom_ly + (double(i) / double(h - 1)) * (zoom_ry - zoom_ly); for (int j = 0; j \u0026lt; w; j++) { double zx = zoom_lx + (double(j) / double(w - 1)) * (zoom_rx - zoom_lx); complex\u0026lt;double\u0026gt; z(zx, zy); uint8_t n = mandelbrot(z, max_iter); double r = (108 * n) % 256, g = (88 * n) % 256, b = (245 * n) % 256; fprintf(fp, \u0026#34;%c%c%c\u0026#34;, uint8_t(r), uint8_t(g), uint8_t(b)); } } fclose(fp); return 0; } 该代码会在执行文件同目录下生成一个 mandelbrot_frac_cpp.ppm 文件，linux系统可直接打开，windows系统上可使用一些转换工具，或者使用如下 python 脚本：\nfrom PIL import Image import sys im = Image.open(sys.argv[1]) im.show() im.save(open(sys.argv[2], \u0026#39;wb\u0026#39;)) 将上面脚本保存为 ppm2png.py 文件，然后命令行中运行：\npy ppm2png.py mandelbrot_frac_cpp.ppm mandelbrot_frac_cpp.png 即可看到 png 格式的分形图像：\n实际上我还没研究明白如何才能等比例无限放大 mandelbrot 分形的局部。\nPython:\nimport numpy as np import cv2 as cv xa = -2.0 xb = 1.0 ya = -1.5 yb = 1.5 maxIt = 1000 imgx = 1200 imgy = 1200 image = np.zeros((imgx, imgy, 3), np.uint8) for y in range(imgy): zy = y * (yb - ya) / (imgy - 1) + ya for x in range(imgx): zx = x * (xb - xa) / (imgx - 1) + xa z = zx + zy * 1j c = z i = 0 while i \u0026lt; maxIt: if abs(z) \u0026gt; 2.0: break z = z * z + c i += 1 r = i * 128 % 256 g = i * 2 % 256 b = i * 2 % 256 image[y, x] = [int(b), int(g), int(r)] cv.imwrite(\u0026#39;mandelbort_frac_py.png\u0026#39;, image) 该代码将输出一个 mandelbrot_frac_py.png 文件：\nNewton fractal #\r这是一篇介绍牛顿迭代法的分形文章：\rhttps://www.chiark.greenend.org.uk/~sgtatham/newton/\n这里画一个使用牛顿迭代 \\( z = z^5 - 1 \\) 的 \\(5\\) 个根所产生的分形图像。\nC/C++:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;complex\u0026gt; class Vec3b { public: Vec3b(uint8_t r, uint8_t g, uint8_t b) : e{r, g, b} {} uint8_t r() { return e[0]; } uint8_t g() { return e[1]; } uint8_t b() { return e[2]; } uint8_t operator[](size_t i) { return e[i]; } uint8_t e[3]; } auto fz = [](complex\u0026lt;double\u0026gt; z) { return std::pow(z, 5.) - complex\u0026lt;double\u0026gt;(1., 0.); }; auto dz = [](complex\u0026lt;double\u0026gt; z) { return 5. * std::pow(z, 4.); }; Vec3b fractal(size_t max_it, complex\u0026lt;double\u0026gt; z, complex\u0026lt;double\u0026gt; roots[], Vec3b color[]) { double a = -0.5; for (size_t k = 0; k \u0026lt; max_it; k++) { z -= fz(z) / dz(z); for (size_t r = 0; r \u0026lt; 5; r++) { complex\u0026lt;double\u0026gt; distance = z - roots[r]; if (std::abs(distance) \u0026lt; 1e-6) return Vec3b( (color[r][0] * k) % 256, (color[r][1] * k) % 256, (color[r][2] * k) % 256); } } return color[5]; } int main() { size_t w = 500, h = 500; FILE* fp = fopen(\u0026#34;picture.ppm\u0026#34;, \u0026#34;wb\u0026#34;); fprintf(fp, \u0026#34;P6 %d %d 255 \u0026#34;, w, h); complex\u0026lt;double\u0026gt; roots[5] = { complex\u0026lt;double\u0026gt;(1, 0), complex\u0026lt;double\u0026gt;(-(std::sqrt(5) + 1) / 4., -std::sqrt((5 - std::sqrt(5)) / 8.)), complex\u0026lt;double\u0026gt;((std::sqrt(5) - 1) / 4., std::sqrt((5 + std::sqrt(5)) / 8.)), complex\u0026lt;double\u0026gt;((std::sqrt(5) - 1) / 4., -std::sqrt((5 + std::sqrt(5)) / 8.)), complex\u0026lt;double\u0026gt;(-(1. + std::sqrt(5)) / 4., std::sqrt((5 - std::sqrt(5)) / 8.)), }; Vec3b color[6] = { Vec3b(130, 18, 245), Vec3b(44, 245, 18), Vec3b(254, 183, 18), Vec3b(245, 14, 160), Vec3b(14, 121, 245), Vec3b(0, 0, 0) }; for (size_t i = 0; i \u0026lt; h; i++) { double zy = 10. * (double(i) / double(h - 1)) - 5.; for (size_t j = 0; j \u0026lt; w; j++) { double zx = 10. * (double(j) / double(w - 1)) - 5.; complex\u0026lt;double\u0026gt; z(zx, zy); Vec3b c = fractal(100, z, roots, color); fprintf(fp, \u0026#34;%c%c%c\u0026#34;, c.r(), c.g(), c.b()); } } fclose(fp); return 0; } 该代码将输出如下图像结果：\nJulia set #\r","date":"2020-11-01","externalUrl":null,"permalink":"/docs/2020-11-01-fractal-set/","section":"Docs","summary":"","title":"分形","type":"docs"},{"content":"","date":"2018-10-24","externalUrl":null,"permalink":"/tags/machine-leraning/","section":"Tags","summary":"","title":"Machine Leraning","type":"tags"},{"content":"\r机器学习可以做许多有趣的事情，每个技术方向都有入门例子，但实际上只是照着入门例子抄，然后跑一遍可能对入门并没有帮助。于是我就个人入门经验，用自己的例子来做一个入门指导吧。\n虽然是入门，但这里并不会指导进行环境搭建，所以，在看这篇文章之前，请先准备好机器学习的环境。\n你将会了解到的 #\r什么是数据集 如何训练模型 如何保存模型 模型的复用 什么是数据集 #\r数据集一般也分为训练集和测试集，顾名思义，训练集用于训练，测试集用来测试训练好的模型的效果如何（有的数据集会包含验证集）。\n首先我的例子是这样的：\n预测方程 \\( a_n = a_{n - 2} + a_{n - 4} + 1 \\) 的第 \\( n \\) 项的值。（不要求答案完全正确，误差任意吧）\n正常来说，这种问题不会用机器学习来做，明明可以写个递归跑，干嘛焉用牛刀，而且误差还很大？嘛\u0026hellip;就当计算非常大的项 \\( n \\) 时，计算很慢，且只想知道值大概范围，那么你可以继续往下看。。。\n我们需要有数据集，把数据喂给算法模型就是一个训练过程或者说算法的学习过程，那么如何制作数据集呢？\n先考虑下面代码：\ndef recursive(x): if x \u0026lt;= 2: return 1 else: return recursive(x - 2) + recursive(x - 4) + 1 直接把公式翻译成python代码，但当计算80+以上的项，python变得十分的慢，因为这是一个 n 次方时间复杂度的计算过程，有很多重复计算的部分，所以我们考虑优化成线性时间复杂度：\n注意到奇数项 = 偶数项，所以我们只需要计算奇数项。偶数项则通过减 \\( 1 \\) 变为计算奇数项即可。而奇数项等于两个等差数列为 \\( 2 \\) 的更小的奇数项的和加 \\( 1 \\)，即 \\( a_n = a_{n-2} + a_{n-4} + 1 \\)，所以得到下面优化的线性时间复杂度的算法：\ndef r(n): def it(a, b, i): if i \u0026lt;= 2: return a elif i % 2 == 0: return it(a, b, i - 1) else: return it(a + b + 1, a, i - 2) return it(1, 1, n) 我们使用这个更快的算法来生成数据：\nimport pandas as pd def r(n): def it(a, b, i): if i \u0026lt;= 2: return a elif i % 2 == 0: return it(a, b, i - 1) else: return it(a + b + 1, a, i - 2) return it(1, 1, n) x = [] y = [] c = 1 for i in range(100): x.append(i) if i % 2 != 0: c = r(i) y.append(c) save = pd.DataFrame({\u0026#39;data\u0026#39;: x, \u0026#39;result\u0026#39;: y}) save.to_csv(\u0026#39;train.csv\u0026#39;, index=False) 这里我还做了一点处理，偶数项直接使用奇数项的，这样就不用再重复计算减 \\1\\ 的奇数项。\n现在，数据准备好了，这里我选择0~80用来训练，80~100用来测试。你可以用两个文件中分别保存训练集和测试集，也可以把所有数据放在同一个文件，然后训练时只取一部分。我用了单个文件。\n如何训练模型 #\r前面也提到这是一个回归任务，虽然方法很多，那么至少应该要知道其中一种方法，可以用 sklearn 提供的 linear_model 来做一个简单的最小二乘法拟合数据。嘛，当然仅使用线性回归对于该问题是不合适的。\n我们准备好需要导入的包：\nimport pandas as pd import numpy as np import seaborn as sns import matplotlib.pyplot as plt from sklearn.metrics import mean_squared_error, r2_score from sklearn.linear_model import LinearRegression from sklearn.externals import joblib 问题很单一，也限定了数据，所以我们不需要数据预处理。。。\n可以先看看数据曲线，这是一种非常有用且直观的方法以了解数据：\ndata = pd.read_csv(\u0026#39;train.csv\u0026#39;) sns.lmplot(x=\u0026#39;data\u0026#39;, y=\u0026#39;result\u0026#39;, data=data) plt.show() 然后使用模型算法：\ntrain_X, train_y = data.iloc[:, :-1].values, data[\u0026#39;result\u0026#39;] clf = LinearRegression() 拟合数据：\nclf.fit(train_X, train_y) 查看拟合系数：\nprint(\u0026#39;参数：\u0026#39;, clf.coef_) 对比源数据和预测结果：\nfig, ax = plt.subplots() ax.scatter(train_X, train_y, label=\u0026#39;Origin data\u0026#39;, c=\u0026#39;orange\u0026#39;) ax.plot(train_X, clf.predict(train_X), label=\u0026#39;Predict data\u0026#39;) ax.set_xlabel(\u0026#39;data\u0026#39;) ax.set_ylabel(\u0026#39;result\u0026#39;) ax.legend() plt.show() 显然，非线性回归算法更合适，但这里我们学会了如何使用sklearn提供的工具来完成简单的回归任务。\n保存模型 #\rsklearn保存模型很简单（2020/12/04 更新：但似乎joblib功能要从sklearn中删除了，好久没用了。。）：\njoblib.dump(clf, \u0026#39;save_model.m\u0026#39;) 模型的复用 #\r上面保存了训练好的模型，我们随时可以使用它:\ntest = pd.read_csv(\u0026#39;test.csv\u0026#39;) test_X, test_y = test.iloc[:, :-1].values, test[\u0026#39;result\u0026#39;] clf = joblib.load(\u0026#39;save_model.m\u0026#39;) pred = clf.predict(test_X) # 预测 print(pred) print(\u0026#39;均方误差：%.2f\u0026#39; % mean_squared_error(y_true=test_y, y_pred=pred)) print(\u0026#39;评分：%.2f\u0026#39; % r2_score(y_true=test_y, y_pred=pred)) 完整代码 #\rimport pandas as pd import numpy as np import seaborn as sns import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score from sklearn.externals import joblib data = pd.read_csv(\u0026#39;train.csv\u0026#39;) sns.lmplot(x=\u0026#39;data\u0026#39;, y=\u0026#39;result\u0026#39;, data=data) plt.show() train_X, train_y = data.iloc[:, :-1].values, data[\u0026#39;result\u0026#39;] clf = LinearRegression() clf.fit(train_X, train_y) print(\u0026#39;参数：\u0026#39;, clf.coef_) fig, ax = plt.subplots() ax.scatter(train_X, train_y, label=\u0026#39;Origin data\u0026#39;) ax.plot(train_X, clf.predict(train_X), label=\u0026#39;Predict data\u0026#39;) ax.set_xlabel(\u0026#39;data\u0026#39;) ax.set_ylabel(\u0026#39;result\u0026#39;) ax.legend() plt.show() joblib.dump(clf, \u0026#39;save_model.m\u0026#39;) test = pd.read_csv(\u0026#39;test.csv\u0026#39;) test_X, test_y = test.iloc[:, :-1].values, test[\u0026#39;result\u0026#39;] clf = joblib.load(\u0026#39;save_model.m\u0026#39;) pred = clf.predict(test_X) # 预测 print(pred) print(\u0026#39;均方误差：%.2f\u0026#39; % mean_squared_error(y_true=test_y, y_pred=pred)) print(\u0026#39;评分：%.2f\u0026#39; % r2_score(y_true=test_y, y_pred=pred)) ","date":"2018-10-24","externalUrl":null,"permalink":"/docs/2018-10-24-machine-learning/","section":"Docs","summary":"","title":"使用 sklearn 机器学习包","type":"docs"},{"content":"详见:\rSuffix tree\n路径压缩版后缀树 #\r#include \u0026lt;iostream\u0026gt; using namespace std; #define rep(i, a, b) for(int i = a; i \u0026lt; b; i++) #define trans(c) (c - \u0026#39;a\u0026#39;) #define SIZE 26 #define MAX (100010 \u0026lt;\u0026lt; 2) struct BaseNode { int len; const char*s; int pos[MAX]; BaseNode*next[SIZE]; BaseNode() { len = 0; rep(i, 0, MAX) pos[i] = 0; rep(i, 0, SIZE) next[i] = nullptr; } BaseNode(const char*s, int p) { this-\u0026gt;s = s, this-\u0026gt;len = p; rep(i, 0, MAX) pos[i] = 0; rep(i, 0, SIZE) next[i] = nullptr; } }; class SuffixTree { private: BaseNode*root; /**/ void add(const char*s, int p); void print(BaseNode*r); void destory(BaseNode*\u0026amp;r); public: SuffixTree() { root = nullptr; } void insert(const char*s); void insert(string s) { insert(s.c_str()); } void remove(const char*s) { } void visual() { print(root); } bool match(const char*s); bool match(string s) { match(s.c_str()); } ~SuffixTree() { destory(root); } }; void SuffixTree::add(const char*s, int p) { int i = 0; while (s[i]) i++; if (!root-\u0026gt;next[p]) root-\u0026gt;next[p] = new BaseNode(s, i); root-\u0026gt;next[p]-\u0026gt;pos[i] = i; } void SuffixTree::insert(const char*s) { root = new BaseNode(); while (*s) { add(s, trans(*s)); s++; } } bool SuffixTree::match(const char*s) { const char* ps = root-\u0026gt;next[trans(*s)]-\u0026gt;s; while (*s) if (*ps++ != *s++) return false; return true; } void SuffixTree::print(BaseNode*r) { if (r) { rep(i, 0, SIZE) if (r-\u0026gt;next[i]) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; endl; rep(j, 0, r-\u0026gt;next[i]-\u0026gt;len + 1) if (r-\u0026gt;next[i]-\u0026gt;pos[j]) { rep(k, 0, r-\u0026gt;next[i]-\u0026gt;pos[j]) cout \u0026lt;\u0026lt; r-\u0026gt;next[i]-\u0026gt;s[k]; cout \u0026lt;\u0026lt; \u0026#39;$\u0026#39; \u0026lt;\u0026lt; endl; } } } } void SuffixTree::destory(BaseNode*\u0026amp;r) { if (r) { rep(i, 0, SIZE) destory(r-\u0026gt;next[i]); delete r; } } int main() { SuffixTree st; st.insert(\u0026#34;banana\u0026#34;); st.visual(); if (st.match(\u0026#34;na\u0026#34;)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 输出：\n0:\ra$\rana$\ranana$\r1:\rbanana$\r13:\rna$\rnana$\rYes ","date":"2018-09-25","externalUrl":null,"permalink":"/docs/2018-09-25-suffix-tree/","section":"Docs","summary":"","title":"后缀树","type":"docs"},{"content":"","date":"2018-09-13","externalUrl":null,"permalink":"/tags/prime/","section":"Tags","summary":"","title":"Prime","type":"tags"},{"content":"\r这里介绍几种快速求素数的算法。\nSieve of Eratosthenes (埃氏筛) #\r时间复杂度：\\( O(nlglgn) \\)\n埃氏筛 - 维基百科\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2000010; int main(int n, char**v) { bool prime[N]; for(int i = 2; i \u0026lt; N; i++) prime[i] = true; for (int i = 2; i \u0026lt;= sqrt(N); i++) if (prime[i]) for (int j = i*i; j \u0026lt; N; j += i) prime[j] = false; for (int i = 2; i \u0026lt; N; i++) if (prime[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } Sieve of Atkin #\r参见：\rSieve of Atkin - wikipedia\nSieve of prime (素数筛) #\r学会这个筛法就可以A掉这个题了：P3383 【模板】线性筛\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define rg register const int N = 10000010; int prime[N], notprime[N]; void SievePrime() { int step = 0; notprime[1] = 1; for (rg int i = 2; i \u0026lt; N; i++) { if (!notprime[i]) prime[++step] = i; for (rg int j = 1; j \u0026lt;= step \u0026amp;\u0026amp; prime[j] * i \u0026lt; N; j++) { notprime[i * prime[j]] = 1; if (i%prime[j] == 0) break; } } } int main() { SievePrime(); for (rg int i = 0; i \u0026lt; N; i++) if (prime[i]) cout \u0026lt;\u0026lt; prime[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } Sieve of Euler (欧拉筛) #\r原理 #\r欧拉函数 #\r\\( \\phi(n) = n \\prod_{p|n} (1 - \\frac{1}{p}) = \\prod(p - 1)p^{k_r - 1} \\)\n其中 \\( p \\) 为 \\( n \\) 的所有质因子。它表示在不超过 \\( n \\) 的正整数中与 \\( n \\) 互质的数的个数。\n如果 \\( p \\) 是素数，\\( k \\geq 1 \\)，那么有\n\\( \\phi(p^k) = p^{k - 1}(p - 1) = p^k(1 - \\frac{1}{p}) \\)\n利用这个公式便可以证明欧拉函数。\n注意欧拉函数是\r积性函数，这个性质很重要。\n首先 \\( n = p_1^{k_1} \\cdots p_r^{k_r} \\)，则\n$$ \\begin{aligned} \\phi(n) \u0026amp;= \\phi(p_1^{k_1})\\phi(p_2^{k_2}) \\cdots \\phi(p_r^{k_r}) \\\\ \u0026amp;= p_1^{k_1}(1 - \\frac{1}{p_1})p_2^{k_2}(1 - \\frac{1}{p_2}) \\cdots p_r^{k_r}(1 - \\frac{1}{p_r}) \\\\ \u0026amp;= p_1^{k_1}p_2^{k_2} \\cdots p_r^{k_r}(1 - \\frac{1}{p_1})(1 - \\frac{1}{p_2}) \\cdots (1 - \\frac{1}{p_r}) \\\\ \u0026amp;= n(1 - \\frac{1}{p_1})(1 - \\frac{1}{p_2}) \\cdots (1 - \\frac{1}{p_r}) \\end{aligned} $$\n与欧拉定理、费马小定理的关系 对任何两个互质的正整数 \\( a, m (m \u0026gt;= 2) \\)，有欧拉定理 \\( a^{\\phi(m)} = 1(mod \\ m) \\) (其中 \\( \\phi(m) \\) 是欧拉函数) ，当 \\(( m \\) 是质数 \\ p \\) 时，式子变为\n\\( x^{p - 1} = 1(mod \\ p) \\)\n即费马小定理。\n更多关于欧拉函数，另请参见：\n欧拉函数 - 百度百科 Euler function - wikipedia 求欧拉函数的算法 #\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int eular(int n) { int ret=1; for(int i = 2; i*i \u0026lt;= n; i++) { if(n%i == 0) { n /= i,ret *= i - 1; while(n%i == 0) n /= i, ret *= i; } } if(n \u0026gt; 1) ret *= n - 1; return ret; } int main() { int n, s; cin \u0026gt;\u0026gt; n; s = eular(n); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 欧拉筛法实现 #\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define rg register const int N = 10000010; int prime[N], notprime[N], phi[N]; void SieveEuler() { int step = 0; phi[1] = 1; for (rg int i = 2; i \u0026lt; N; i++) { if (!notprime[i]) prime[++step] = i, phi[i] = i - 1; for (rg int j = 1; j \u0026lt;= step \u0026amp;\u0026amp; prime[j] * i \u0026lt; N; j++) { notprime[i * prime[j]] = 1; if (i%prime[j] == 0) { phi[i * prime[j]] = phi[i] * prime[j]; break; } else phi[i * prime[j]] = phi[i]*(prime[j] - 1); } } } int main() { SieveEuler(); for (rg int i = 0; i \u0026lt; N; i++) if (prime[i]) cout \u0026lt;\u0026lt; prime[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } Sieve of Mobius (莫比乌斯筛) #\r原理 #\r莫比乌斯函数 #\r\\( \\mu(n) = \\eta_{\\omega(n)}^{\\Omega(n)}\\lambda(n) \\)\n这里 \\( \\lambda(n) \\) 是刘维尔函数。\n莫比乌斯函数的定义：\nFor any positive integer n, define μ(n) as the sum of the primitive nth roots of unity. It has values in {−1, 0, 1} depending on the factorization of n into prime factors:\nμ(n) = 1 if n is a square-free positive integer with an even number of prime factors. μ(n) = −1 if n is a square-free positive integer with an odd number of prime factors. μ(n) = 0 if n has a squared prime factor. 莫比乌斯函数完整定义的通俗表达：\n莫比乌斯函数 \\( \\mu(n) \\) 的定义域是 \\( N \\); \\( \\mu(1) = 1 \\); 当\\( n \\)存在平方素因子时，\\( \\mu(n) = 0 \\); 当\\( n \\)是素数或奇数个不同素因子之积时，\\( \\mu(n) = -1 \\); 当\\( n \\)是偶数个不同素因子之积时，\\( \\mu(n) = 1 \\). 即\n$$ \\mu(n) = \\left( \\begin{aligned} \u0026amp; 1 \\quad n = 1; \\\\ \u0026amp; (-1)^k \\quad n 是无平方因数且 n = p_1 p_2 \\cdots p_k \\\\ \u0026amp; 0 \\quad n 有大于 1 的平方因数. \\end{aligned} \\right. $$\n莫比乌斯函数也是一个积性函数（\\( \\mu(ab) = \\mu(a)\\mu(b) \\)，\\( a \\) 和 \\( b \\) 互质 ）\n当 \\( n = 1 \\) 时，\\( n \\) 的所有因子的莫比乌斯函数值和为 \\( 1 \\); 当 \\( n \\neq 1 \\) 时，\\( n \\) 的所有因子的莫比乌斯函数值和为 \\( 0 \\). 即\n$$ \\sum_{d|n}\\mu(d) = \\left( \\begin{aligned} 1 \\quad n = 1; \\\\ 0 \\quad n \u0026gt; 1. \\end{aligned} \\right. $$\n参考：\n莫比乌斯函数 - 百度百科 Mobius function - wikipedia 莫比乌斯筛法实现 #\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define rg register const int N = 1000010; int prime[N], notprime[N], mobius[N]; void SieveMobius() { int step = 0; mobius[1] = 1; for (rg int i = 2; i \u0026lt; N; i++) { if (!notprime[i]) prime[++step] = i, mobius[i] = -1; for (rg int j = 1; j \u0026lt;= step \u0026amp;\u0026amp; prime[j] * i \u0026lt; N; j++) { notprime[i * prime[j]] = 1; if (i%prime[j] == 0) { mobius[i * prime[j]] = 0; break; } else mobius[i * prime[j]] = -mobius[i]; } } } int main() { SieveMobius(); for (int i = 0; i \u0026lt; N; i++) if (prime[i]) cout \u0026lt;\u0026lt; prime[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } 其他参考 #\r线性筛 几种线性筛 ","date":"2018-09-13","externalUrl":null,"permalink":"/docs/2018-09-13-sieve/","section":"Docs","summary":"","title":"筛法","type":"docs"},{"content":"","date":"2018-09-09","externalUrl":null,"permalink":"/tags/sorting/","section":"Tags","summary":"","title":"Sorting","type":"tags"},{"content":"\r简介 #\r计数排序是一种空间换时间的排序算法。通常用作\r基数排序的子过程。\n参考文献 #\rCounting sort - wikipeida 计数排序 - 百度百科 Counting sort - geeksforgeeks 算法实现 #\r#include \u0026lt;iostream\u0026gt; using namespace std; const int MAXN = 100000; const int k = 1000; int a[MAXN], c[MAXN], ranked[MAXN]; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a[i]; ++c[a[i]]; } for (int i = 1; i \u0026lt; k; ++i) c[i] += c[i - 1]; for (int i = n - 1; i \u0026gt;= 0; --i) ranked[--c[a[i]]] = a[i]; for (int i = 0; i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; ranked[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } 算法分析 #\r时间复杂度 \\( O(n + k) \\)\n空间复杂度 \\( O(n + k) \\)\n","date":"2018-09-09","externalUrl":null,"permalink":"/docs/2018-09-09-counting-sort/","section":"Docs","summary":"","title":"计数排序","type":"docs"},{"content":"\r这篇主要介绍一些矩阵运算相关算法。\n矩阵乘法 #\r矩阵相乘：\\( C = AB \\)\n普通算法 #\r时间复杂度 \\( O(N^3) \\) for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) for (int k = 0; k \u0026lt; N; k++) c[i][j] += a[i][k] * b[k][j]; Strassen算法 #\r时间复杂度 \\( O(N^{lg7}) \\) void Strassen_algo(vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; \u0026amp; c, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; a, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; b) { } 线性方程组 #\r\\( n \\) 个未知数 \\( m \\) 个方程的线性方程组\n$$ \\left( \\begin{matrix} a_{00}x_0 \u0026amp; a_{01}x_1 \u0026amp; \\cdots \u0026amp; a_{0n}x_n \u0026amp;= b_0 \\\\ a_{10}x_0 \u0026amp; a_{11}x_1 \u0026amp; \\cdots \u0026amp; a_{1n}x_n \u0026amp;= b_1 \\\\ \\vdots \\\\ a_{m0}x_0 \u0026amp; a_{m1}x_1 \u0026amp; \\cdots \u0026amp; a_{mn}x_n \u0026amp;= b_m \\end{matrix} \\right. $$\n将上式写为以向量 \\( x \\) 为未知元的向量方程\n$$ Ax = b \\quad (1) $$\n方程是否有解 #\r设 \\( B = (A, b) \\) 为增广矩阵，\\( R(A) \\) 是矩阵 \\( A \\) 的秩，\\( R(A, b) \\) 是增广矩阵 \\( B \\) 的秩。\n无解的充分必要条件是 \\( R(A) \u0026lt; R(A, b) \\); \\( n \\) 元线性方程组 \\( Ax = b \\quad \\) 有唯一解的充分必要条件是 \\( R(A) = R(A, b) = n \\); 有无限多解的充分必要条件是 \\( R(A) = R(A, b) \\leq n \\). LUP分解原理 #\r\\( LUP \\) 分解的基本思想就是找出三个 \\( n \\times n \\) 矩阵 \\( L, U, P \\)，满足\n$$ PA = LU \\quad (2) $$\n其中，\\( L \\) 是一个单位下三角矩阵，\\( U \\) 是一个上三角矩阵，\\( P \\) 是一个置换矩阵。我们称满足式 \\( (2) \\) 的矩阵 \\( L, U, P \\) 为矩阵 \\( A \\) 的 \\( LUP \\) 分解。\n可以证明，如果矩阵 \\( A \\) 是一个非奇异矩阵，那么我们一定能找到 \\( L, U, P \\) 分解满足上式。\n这有什么用呢？\n我们先对 \\( (1) \\) 进行置换，在等式 \\( Ax = b \\) 两边同时乘以 \\( P \\) 置换，得到：\n$$ PAx = Pb $$\n利用 \\( (2) \\) 式有 \\( LUx = Pb \\)。\n设 \\( y = Ux \\)，其中 \\( x \\) 就是要求解的向量解。首先，通过一种称为“正向替换”的方法求解单位下三角系统\n$$ Ly = Pb \\quad (3) $$\n得到未知向量 \\( y \\)。然后，通过一种称为“反向替换”的方法求解上三角系统\n$$ Ux = y \\quad (4) $$\n得到向量解 \\( x \\)。由于置换矩阵 \\( P \\) 是可逆的，在等式 \\( (2) \\) 两边同时乘以 \\( P^{-1} \\)，于是 \\( A = P^{-1}LU \\)，因此，向量 \\( x \\) 就是 \\( Ax = b \\) 的解\n$$ \\begin{aligned} Ax \u0026amp;= P^{-1}LUx\\\\ \u0026amp;= P^{-1}Ly\\\\ \u0026amp;= P^{-1}Pb\\\\ \u0026amp;= b \\end{aligned} $$\n正向替换与反向替换 #\r进一步看看正向替换与反向替换是如何进行的。\n正向替换 已知 \\( L, P \\) 和 \\( b \\)，正向替换可在 \\( O(n^2) \\) 的时间内求解单位下三角系统 \\( (3) \\)。\n$$ Pb = \\begin{bmatrix} p_{0,0} \u0026amp; p_{0,1} \u0026amp; \\cdots \u0026amp; p_{0,n} \\\\ p_{1,0} \u0026amp; p_{1,1} \u0026amp; \\cdots \u0026amp; p_{1,n} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\cdots \u0026amp; \\vdots \\\\ p_{n,0} \u0026amp; p_{n,1} \u0026amp; \\cdots \u0026amp; p_{n,n} \\end{bmatrix} \\begin{bmatrix} b_0 \\\\ b_1 \\\\ \\vdots \\\\ b_n \\end{bmatrix} = \\begin{bmatrix} \\sum_{j = 0}^{n}p_{0,j} \\cdot b_j \\\\ \\sum_{j = 0}^{n}p_{1,j} \\cdot b_j \\\\ \\vdots \\\\ \\sum_{j = 0}^{n}p_{n,j} \\cdot b_j \\end{bmatrix} $$\n为了方便起见，这里用一个数组 \\( \\pi[0\u0026hellip;n] \\) 简洁地表示置换 \\( P \\)。对 \\( i = 0, 1, 2, \\cdots, n \\)，元素 \\( \\pi[i] \\) 表示 \\( P_{i, \\pi[i]} = 1 \\)，并且对 \\( j \\neq \\pi[i] \\) 有 \\( P_{ij} = 0 \\)。因此，\\( PA \\) 第 \\( i \\) 行第 \\( j \\) 列的元素为 \\( a_{\\pi[i],j} \\)，\\( Pb \\) 的第 \\( i \\) 个元素为 \\( b_{\\pi[i]} \\)。因为 \\( L \\) 是单位下三角矩阵，我们可以重写等式 \\( (3) \\) 为：\n$$ \\begin{bmatrix} y_0 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp;= b_{\\pi[0]} \\\\ l_{10}y_0 \u0026amp; + \u0026amp; y_1 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp;= b_{\\pi[1]} \\\\ l_{20}y_0 \u0026amp; + \u0026amp; l_{21}y_1 \u0026amp; + \u0026amp; y_2 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp;= b_{\\pi[2]} \\\\ \\vdots \\\\ l_{n0}y_0 \u0026amp; + \u0026amp; l_{n1}y_1 \u0026amp; + \u0026amp; l_{n2}y_2 \u0026amp; + \u0026amp; \\cdots \u0026amp; + \u0026amp; y_n \u0026amp;= b_{\\pi[n]} \\end{bmatrix} $$\n第一个等式可以求出 \\( y_0 \\)，我们把它代入第二个等式，求出\n$$ y_1 = b_{\\pi[1]} - l_{10}y_0 $$\n在将 \\( y_1, y_2 \\) 代入第三个等式，得到\n$$ y_2 = b_{\\pi[2]} - (l_{20}y_0 + l{21}y_1) $$\n一般的，我们把 \\( y_0, y_1, \\cdots, y_{i - 1} \\) “正向替换”到第 \\( i \\) 个等式中，就可以求解 \\( y_i \\)：\n$$ y_i = b_{\\pi[i]} - \\sum_{j = 0}^{i - 1} l_{ij}y_{j} $$\n反向替换 与正向替换类似，求解上三角系统等式 (4)。\n$$ \\begin{bmatrix} u_{0,0}x_0 \u0026amp; + \u0026amp; u_{0,1}x_1 \u0026amp; + \u0026amp; \\cdots \u0026amp; + \u0026amp; u_{0,n-2}x_{n-2} \u0026amp; + \u0026amp; u_{0,n-1}x_{n-1} \u0026amp; + \u0026amp; u_{0,n}x_n \u0026amp;= y_{0} \\\\ \u0026amp; \u0026amp; u_{1,1}x_1 \u0026amp; + \u0026amp; \\cdots \u0026amp; + \u0026amp; u_{1,n-2}x_{n-2} \u0026amp; + \u0026amp; u_{1,n-1}x_{n-1} \u0026amp; + \u0026amp; u_{1,n}x_n \u0026amp;= y_{1} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\vdots \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; u_{n-2,n-2}x_{n-2} \u0026amp; + \u0026amp; u_{n-2,n-1}x_{n-1} \u0026amp; + \u0026amp; u_{n-2,n}x_n \u0026amp;= y_{n - 2} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; u_{n-1,n-1}x_{n-1} \u0026amp; + \u0026amp; u_{n-1,n}x_n \u0026amp;= y_{n - 1} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; u_{n,n}x_n \u0026amp;= y_{n} \\end{bmatrix} $$\n这里我们先求解第 \\( n \\) 个等式，然后往前一个等式代，因此可以如下相继求出 \\( x_n, x_{n - 1}, \\cdots, x_1 \\) 的解：\n$$ \\begin{aligned} x_n \u0026amp;= \\frac{y_{n}}{u_{n,n}} \\\\ x_{n - 1} \u0026amp;= \\frac{y_{n - 1} - u_{n - 1, n}x_n}{u_{n - 1,n - 1}} \\\\ \\vdots \\end{aligned} $$\n一般的，有\n$$ x_i = \\frac{y_i - \\sum_{j = i + 1}^{n} u_{ij}x_{j}}{u_{ij}} $$\n计算LUP分解 #\r我们该如何找到这样的 \\( L, U, P \\) 矩阵呢？\n通常在 \\( LUP \\) 分解中包含一个置换矩阵 \\( P \\) 的原因是为了避免矩阵 \\( A \\) 中的主元 \\( a_{i,i} = 0 \\)，即矩阵对角线上的数。\n但如果矩阵 \\( A \\) 的对角线上的数都不为 \\( 0 \\)，我们有一个 \\( LU \\) 分解算法就可以计算出矩阵 \\( L, U \\)。\n下面先给出 \\( LU \\) 分解算法的实现，之后再分析算法原理。\nLU分解算法实现 #\r示例:\n$$ \\begin{bmatrix} 2 \u0026amp; 3 \u0026amp; 1 \u0026amp; 5 \\\\ 6 \u0026amp; 13 \u0026amp; 5 \u0026amp; 19 \\\\ 2 \u0026amp; 19 \u0026amp; 10 \u0026amp; 23 \\\\ 4 \u0026amp; 10 \u0026amp; 11 \u0026amp; 31 \\\\ \\end{bmatrix} $$\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; const int N = 4; using namespace std; void lu(vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; \u0026amp;l, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; \u0026amp;u, float a[][N]) { for (int i = 0; i \u0026lt; N; i++) { l[i][i] = 1; for (int j = i + 1; j \u0026lt; N; j++) l[i][j] = 0; } for (int i = 1; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; i; j++) u[i][j] = 0; for (size_t i = 0; i \u0026lt; N; i++) { u[i][i] = a[i][i]; for (size_t j = i + 1; j \u0026lt; N; j++) { l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; } for (size_t j = i + 1; j \u0026lt; N; j++) for (size_t k = i + 1; k \u0026lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; } } int main() { vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; l(N, vector\u0026lt;float\u0026gt;(N)); vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; u(N, vector\u0026lt;float\u0026gt;(N)); float a[N][N] = { 2, 3, 1, 5, 6, 13, 5, 19, 2, 19, 10, 23, 4, 10, 11, 31 }; lu(l, u, a); cout \u0026lt;\u0026lt; \u0026#34;L 矩阵:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; N; j++) cout \u0026lt;\u0026lt; l[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;U 矩阵:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; N; j++) cout \u0026lt;\u0026lt; u[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; cout \u0026lt;\u0026lt; endl; } memset(a, 0, sizeof(a)); for (int i = 0; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; N; j++) for (int k = 0; k \u0026lt; N; k++) a[i][j] += l[i][k] * u[k][j]; cout \u0026lt;\u0026lt; \u0026#34;A 矩阵:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; N; j++) cout \u0026lt;\u0026lt; a[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; cout \u0026lt;\u0026lt; endl; } return 0; } LU分解算法分析 #\r前面说到对于一个非奇异矩阵 \\( A \\)，即 \\( \\det{A} \\neq 0 \\)，就能找到其 \\( LU \\) 分解，那么运用正向替换与反向替换就可以求出线性方程组 \\( Ax = b \\) 的解。\n原理：算法利用高斯消元法来创建 \\( LU \\) 分解。首先从其他方程中减去第一个方程的倍数，以把那些方程中的第一个变量消去。然后，从第三个及以后的方程中减去第二个方程的倍数，把这些方程的第一个和第二个变量消去。继续上述过程，直到系统变为一个上三角矩阵形式，实际上此矩阵就是 \\( U \\)。矩阵 \\( L \\) 是由消去变量所用的行的乘数组成。\n采用递归算法实现这个策略。我们希望构造出一个 \\( n \\times n \\) 的非奇异矩阵 \\( A \\) 的一个 \\( LU \\) 分解。 如果 \\( n = 1 \\)，则构造完成，因为可以算则 \\( L = I_1 \\) (注：\\( I_n \\) 是单位阵)， \\( U = A \\)。对于 \\( n \u0026gt; 1 \\)，我们把 \\( A \\) 拆成 \\( 4 \\) 部分\n$$ \\begin{bmatrix} a_{11} \u0026amp; | \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n} \\\\ -\u0026amp;-\u0026amp;-\u0026amp;-\u0026amp;- \\\\ a_{21} \u0026amp; | \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n} \\\\ \\vdots \u0026amp; | \\\\ a_{n1} \u0026amp; | \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{bmatrix} = \\begin{bmatrix} a_{11} \u0026amp; \\omega^T \\\\ \\upsilon \u0026amp; A\u0026rsquo; \\end{bmatrix} $$\n其中 \\( \\upsilon \\) 是一个 \\( n - 1 \\) 维列向量，\\( \\omega^T \\) 是一个 \\( n - 1 \\) 维行向量，\\( A\u0026rsquo; \\) 是一个 \\( (n - 1) \\times (n - 1) \\) 矩阵。然后，利用矩阵代数 (通过简单地从头到尾使用乘法来验证方程式)，可以把 \\( A \\) 分解为\n$$ \\begin{bmatrix} 1 \u0026amp; 0 \\\\ \\frac{\\upsilon}{a_{11}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{11} \u0026amp; \\omega^T \\\\ 0 \u0026amp; A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{11}} \\end{bmatrix} $$\n项 \\( \\frac{\\upsilon\\omega^T}{a_{11}} \\) 是一个 \\( (n - 1) \\times (n - 1) \\) 矩阵，它与矩阵 \\( A\u0026rsquo; \\) 大小一致。所得矩阵\n$$ A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{11}} $$\n称为矩阵 \\( A \\) 对于 \\( a_{11} \\) 的\r舒尔补。\n如果矩阵 \\( A \\) 是非奇异的，那么舒尔补矩阵也是非奇异的。\n因为舒尔补是非奇异的，现在我们可以递归地找出它的一个 \\( LU \\) 分解。我们说\n$$ A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{11}} = L\u0026rsquo;U\u0026rsquo; $$\n其中 \\( L\u0026rsquo; \\) 是单位下三角矩阵，\\( U\u0026rsquo; \\) 是上三角矩阵。然后，利用矩阵代数可得\n$$ \\begin{aligned} A \u0026amp;= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ \\frac{\\upsilon}{a_{00}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{00} \u0026amp; \\omega^T \\\\ 0 \u0026amp; A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{00}} \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ \\frac{\\upsilon}{a_{00}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k0} \u0026amp; \\omega^T \\\\ 0 \u0026amp; L\u0026rsquo;U\u0026rsquo; \\end{bmatrix} \\\\ \u0026amp;= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ \\frac{\\upsilon}{a_{00}} \u0026amp; L\u0026rsquo; \\end{bmatrix} \\begin{bmatrix} a_{00} \u0026amp; \\omega^T \\\\ 0 \u0026amp; U\u0026rsquo; \\end{bmatrix} = LU \\end{aligned} $$\n时间复杂度 \\( O(N^3) \\) LUP分解算法实现 #\r示例:\n$$ \\begin{bmatrix} 2 \u0026amp; 0 \u0026amp; 2 \u0026amp; 0.6 \\\\ 3 \u0026amp; 3 \u0026amp; 4 \u0026amp; -2 \\\\ 5 \u0026amp; 5 \u0026amp; 4 \u0026amp; 2 \\\\ -1 \u0026amp; -2 \u0026amp; 3.4 \u0026amp; -1 \\end{bmatrix} $$\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; const int N = 4; using namespace std; void lup(vector\u0026lt;float\u0026gt; \u0026amp;P, float a[][N]) { for (size_t i = 0; i \u0026lt; N; i++) { float p = 0; size_t i_; for (size_t j = i; j \u0026lt; N; j++) if (fabsf(a[j][i]) \u0026gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (size_t j = 0; j \u0026lt; N; j++) swap(a[i][j], a[i_][j]); for (size_t j = i + 1; j \u0026lt; N; j++) { a[j][i] /= a[i][i]; for (size_t k = i + 1; k \u0026lt; N; k++) a[j][k] -= a[j][i] * a[i][k]; } } } int main() { vector\u0026lt;float\u0026gt; P(N); float b[][N] = { 2, 0, 2, 0.6, 3, 3, 4, -2, 5, 5, 4, 2, -1, -2, 3.4, -1 }; lup(P, b); cout \u0026lt;\u0026lt; \u0026#34;B 矩阵:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) { for (int j = 0; j \u0026lt; N; j++) cout \u0026lt;\u0026lt; b[i][j] \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39;; cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;P 矩阵:\u0026#34; \u0026lt;\u0026lt; endl; for (size_t i = 0; i \u0026lt; P.size(); i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; P[i] \u0026lt;\u0026lt; endl; return 0; } 版本 2.\nvoid lup2(vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt;\u0026amp;l, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt;\u0026amp;u, vector\u0026lt;float\u0026gt; \u0026amp;P, float a[][N]) { for (int i = 0; i \u0026lt; N; i++) { l[i][i] = 1; for (int j = i + 1; j \u0026lt; N; j++) l[i][j] = 0; } for (int i = 1; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; i; j++) u[i][j] = 0; for (int i = 0; i \u0026lt; N; i++) { float p = 0; int i_; for (int j = i; j \u0026lt; N; j++) if (fabsf(a[j][i]) \u0026gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (int j = 0; j \u0026lt; N; j++) swap(a[i][j], a[i_][j]); u[i][i] = a[i][i]; for (int j = i + 1; j \u0026lt; N; j++) { l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; } for (int j = i + 1; j \u0026lt; N; j++) for (int k = i + 1; k \u0026lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; } } LUP分解算法分析 #\r原理：算法考虑每次计算过程，若主元为 \\( 0 \\) 或主元的值大于除数时，我们将找到合适的行与当前主元所在的行进行交换。比如，第 \\( 1 \\) 行，第 \\( 1 \\) 列为 \\( 0 \\)，我们把第 \\( 1 \\) 行与第 \\( k \\) 行互换，这等价于用一个置换矩阵 \\( Q \\) 左乘矩阵 \\( A \\)。因此可以把 \\( QA \\) 写成 \\( QA = \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ \\upsilon \u0026amp; A\u0026rsquo; \\end{bmatrix} \\)，其中 \\( \\upsilon = (a_{21}, a_{31}, \\cdots, a_{n1})^T, \\omega^T = (a_{k2}, a_{k3}, \\cdots, a_{kn}) \\)\n\\( A\u0026rsquo; \\) 是一个 \\( (n - 1) \\times (n - 1) \\) 矩阵。因为 \\( a_{k1} \\neq 0 \\)，现在可以执行与 \\( LU \\) 分解基本相同的线性代数运算，但现在能保证不会除以 \\( 0 \\)\n$$ QA = \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ \\upsilon \u0026amp; A\u0026rsquo; \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ \\frac{\\upsilon}{a_{k1}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ 0 \u0026amp; A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{k1}} \\end{bmatrix} $$\n如果 \\( A \\) 是非奇异的，那么舒尔补 \\( A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{k1}} \\) 也是非奇异的。因此，可以递归地找出它的一个 \\( LUP \\) 分解，包括单位下三角矩阵 \\( L\u0026rsquo; \\)、上三角矩阵 \\( U\u0026rsquo; \\) 和置换矩阵 \\( P\u0026rsquo; \\)，满足\n$$ P\u0026rsquo;(A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{k1}}) = L\u0026rsquo;U\u0026rsquo; $$\n定义 $$ P = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; P\u0026rsquo; \\end{bmatrix} Q $$\n它是一个置换矩阵，因为它是两个置换矩阵的乘积。有\n$$ \\begin{aligned} PA \u0026amp;= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; P\u0026rsquo; \\end{bmatrix} QA = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; P\u0026rsquo; \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \\\\ \\frac{\\upsilon}{a_{k1}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ 0 \u0026amp; A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{k1}} \\end{bmatrix} \\\\ \u0026amp;= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ P\u0026rsquo;\\frac{\\upsilon}{a_{k1}} \u0026amp; P\u0026rsquo; \\end{bmatrix} \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ 0 \u0026amp; A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{k1}} \\end{bmatrix} \\\\ \u0026amp;= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ P\u0026rsquo;\\frac{\\upsilon}{a_{k1}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ 0 \u0026amp; P\u0026rsquo;(A\u0026rsquo; - \\frac{\\upsilon\\omega^T}{a_{k1}}) \\end{bmatrix} \\\\ \u0026amp;= \\begin{bmatrix} 1 \u0026amp; 0 \\\\ P\u0026rsquo;\\frac{\\upsilon}{a_{k1}} \u0026amp; I_{n - 1} \\end{bmatrix} \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ 0 \u0026amp; L\u0026rsquo;U\u0026rsquo; \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ P\u0026rsquo;\\frac{\\upsilon}{a_{k1}} \u0026amp; L\u0026rsquo; \\end{bmatrix} \\begin{bmatrix} a_{k1} \u0026amp; \\omega^T \\\\ 0 \u0026amp; U\u0026rsquo; \\end{bmatrix} = LU \\end{aligned} $$\n这样就推出了 \\( LUP \\) 分解。因为 \\( L\u0026rsquo; \\) 是单位下三角矩阵，所以 \\( L \\) 也是单位下三角矩阵；又因为 \\( U\u0026rsquo; \\) 是上三角矩阵，于是 \\( U \\) 也是上三角矩阵。\n时间复杂度 \\( O(N^3) \\) 求解线性方程组算法 #\r有了以上基础知识以后，我们才能得到 \\( L, U, P \\)，步入最后一步求解出线性方程组 \\( Ax = b \\) 的向量解。\n完整的算法实现 #\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; const int N = 3; using namespace std; void lu(vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; \u0026amp;l, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; \u0026amp;u, float a[][N]) { for (int i = 0; i \u0026lt; N; i++) { l[i][i] = 1; for (int j = i + 1; j \u0026lt; N; j++) l[i][j] = 0; } for (int i = 1; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; i; j++) u[i][j] = 0; for (int i = 0; i \u0026lt; N; i++) { u[i][i] = a[i][i]; for (int j = i + 1; j \u0026lt; N; j++) { l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; } for (int j = i + 1; j \u0026lt; N; j++) for (int k = i + 1; k \u0026lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; } } void lup(vector\u0026lt;float\u0026gt; \u0026amp;P, float a[][N]) { for (int i = 0; i \u0026lt; N; i++) { float p = 0; int i_; for (int j = i; j \u0026lt; N; j++) if (fabsf(a[j][i]) \u0026gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (int j = 0; j \u0026lt; N; j++) swap(a[i][j], a[i_][j]); for (int j = i + 1; j \u0026lt; N; j++) { a[j][i] /= a[i][i]; for (int k = i + 1; k \u0026lt; N; k++) a[j][k] -= a[j][i] * a[i][k]; } } } void lup2(vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt;\u0026amp;l, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt;\u0026amp;u, vector\u0026lt;float\u0026gt; \u0026amp;P, float a[][N]) { for (int i = 0; i \u0026lt; N; i++) { l[i][i] = 1; for (int j = i + 1; j \u0026lt; N; j++) l[i][j] = 0; } for (int i = 1; i \u0026lt; N; i++) for (int j = 0; j \u0026lt; i; j++) u[i][j] = 0; for (int i = 0; i \u0026lt; N; i++) { float p = 0; int i_; for (int j = i; j \u0026lt; N; j++) if (fabsf(a[j][i]) \u0026gt; p) p = fabsf(a[j][i]), i_ = j; if (p == 0) return; swap(P[i], P[i_]); for (int j = 0; j \u0026lt; N; j++) swap(a[i][j], a[i_][j]); u[i][i] = a[i][i]; for (int j = i + 1; j \u0026lt; N; j++) { l[j][i] = a[j][i] / u[i][i]; u[i][j] = a[i][j]; } for (int j = i + 1; j \u0026lt; N; j++) for (int k = i + 1; k \u0026lt; N; k++) a[j][k] -= l[j][i] * u[i][k]; } } void lup_solve(vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt;\u0026amp;l, vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt;\u0026amp;u, vector\u0026lt;float\u0026gt;\u0026amp;x, vector\u0026lt;float\u0026gt;\u0026amp;y, vector\u0026lt;float\u0026gt; b, vector\u0026lt;float\u0026gt; P, float a[][N]) { for (int i = 0; i \u0026lt; N; i++) { float sum = 0; for (int j = 0; j \u0026lt; i; j++) sum += l[i][j] * y[j]; y[i] = b[P[i]] - sum; } for (int i = N - 1; i \u0026gt;= 0; i--) { float sum = 0; for (int j = i + 1; j \u0026lt; N; j++) sum += u[i][j] * x[j]; x[i] = (y[i] - sum) / u[i][i]; } } int main() { vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; l(N, vector\u0026lt;float\u0026gt;(N)); vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; u(N, vector\u0026lt;float\u0026gt;(N)); /*float a[][N] = { 2, 3, 1, 5, 6, 13, 5, 19, 2, 19, 10, 23, 4, 10, 11, 31 }; float b[][N] = { 2, 0, 2, 0.6, 3, 3, 4, -2, 5, 5, 4, 2, -1, -2, 3.4, -1 };*/ float c[][N] = { 1, 2, 0, 3, 4, 4, 5, 6, 3 }; vector\u0026lt;float\u0026gt; P(N); vector\u0026lt;float\u0026gt; x(N); vector\u0026lt;float\u0026gt; y(N); vector\u0026lt;float\u0026gt; b { 3, 7, 8 }; for (int i = 0; i \u0026lt; N; i++) P[i] = (float)i; lup2(l, u, P, c); lup_solve(l, u, x, y, b, P, c); cout \u0026lt;\u0026lt; \u0026#34;解向量 x:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; endl; return 0; } 示例：\n$$ \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 0 \\\\ 3 \u0026amp; 4 \u0026amp; 4 \\\\ 5 \u0026amp; 6 \u0026amp; 3 \\end{bmatrix} $$\n输出：\n使用 lup2() 函数\n解向量 x:\r-10.08\r7.94\r1.92 算法分析 #\r显然，代码很直观的实现了对算法的描述过程，即利用正向替换，代换出 \\( Ly = Pb \\) 的 \\( y \\)，然后再利用反向替换计算出 \\( Ux = y \\) 中的解向量 \\( x \\)。\nlup_solve()的时间复杂度为 \\( O(N^2) \\) 矩阵求逆 #\r\\( A\u0026rsquo; \\) 是 \\( A \\) 的逆矩阵，则有 \\( AA\u0026rsquo; = E \\)，其中 \\( E \\) 是单位阵。\n设 \\( X = A\u0026rsquo; \\)， \\( X_i \\) 表示 \\( X \\) 的第 \\( i \\) 列， \\( e_i \\) 是 \\( E \\) 的第 \\( i \\) 列。于是可以利用 \\( A \\) 的 \\( LUP \\) 分解求解方程中的 \\( X \\)，需分别求解每一个方程\n$$ AX_i = e_i $$\n中的 \\( X_i \\)。一旦得到 \\( LUP \\) 分解，就可以在 \\( O(N^2) \\) 时间内计算 \\( n \\) 个 \\( X_i \\) 列中的每一个，因此可以在 \\( O(N^3) \\) 时间内从 \\( A \\) 的 \\( LUP \\) 分解计算 \\( X \\)。既然可以在 \\( O(N^3) \\) 内确定出 \\( A \\) 的 \\( LUP \\) 分解，我们就可以在 \\( O(N^3) \\) 的时间内求矩阵 \\( A \\) 的逆矩阵 \\( A\u0026rsquo; \\)。\n算法演示 #\r示例：\n$$ \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 0 \\\\ 3 \u0026amp; 4 \u0026amp; 4 \\\\ 5 \u0026amp; 6 \u0026amp; 3 \\end{bmatrix} $$\nint main() { vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; l(N, vector\u0026lt;float\u0026gt;(N)); vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; u(N, vector\u0026lt;float\u0026gt;(N)); vector\u0026lt;float\u0026gt; x(N); vector\u0026lt;float\u0026gt; y(N); vector\u0026lt;float\u0026gt; P(N); vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; E { vector\u0026lt;float\u0026gt;{ 1, 0, 0 }, vector\u0026lt;float\u0026gt;{ 0, 1, 0 }, vector\u0026lt;float\u0026gt;{ 0, 0, 1} }; float a[][N] = { 1, 2, 0, 3, 4, 4, 5, 6, 3 }; lup2(l, u, P, a); for (int j = 0; j \u0026lt; E.size(); j++) { lup_solve(l, u, x, y, E[j], P, a); cout \u0026lt;\u0026lt; \u0026#34;解向量 X[\u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34;]:\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; N; i++) cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; endl; } return 0; } 输出：\n解向量 X[0]:\r-1.2\r1.1\r-0.2\r解向量 X[1]:\r-0.6\r0.3\r0.4\r解向量 X[2]:\r0.8\r-0.4\r-0.2 即 $$ A\u0026rsquo;=\\begin{bmatrix} -1.2 \u0026amp; -0.6 \u0026amp; 0.8 \\\\ 1.1 \u0026amp; 0.3 \u0026amp; -0.4 \\\\ -0.2 \u0026amp; 0.4 \u0026amp; -0.2 \\end{bmatrix} $$\n参考文献 #\r[1] 「算法导论・第三版」 [2] matrix multiplicaton - wikipedia ","date":"2018-09-08","externalUrl":null,"permalink":"/docs/2018-09-08-matrix-operations/","section":"Docs","summary":"","title":"矩阵运算","type":"docs"},{"content":"\r这里主要存放一些导数题。\n题目 #\r1.已知向量 \\( a = (\\sin(x), \\frac{3}{4}), b = (\\cos(x), -1) \\).\n(1) 当 \\( a // b \\) 时，求 \\( cos^2(x) - sin(2x) \\)；\n(2) 设函数 \\( f(x) = 2(\\vec{a} + \\vec{b}) \\cdot \\vec{b} \\)，已知在△ABC中，内角 \\( A, B, C \\) 的对边分别为 \\( a, b, c \\)，若 \\( a = \\sqrt{3}, b = 2, \\sin(B) = \\frac{\\sqrt{6}}{3} \\)，求 \\( f(x) + 4 cos(2A + \\frac{\\pi}{6})(x \\in [0, \\frac{\\pi}{3}]) \\) 的取值范围。\n题解：\n(1) 求 \\( \\cos^2(x) - \\sin(2x) \\)\n由 \\( a // b \\)，有 \\( \\tan(x) = -\\frac{3}{4} \\)。\n对 \\( \\cos^2(x) - \\sin(2x) \\) 做一些变形：\n$$ \\begin{aligned} \\cos^2(x) - \\sin(2x) \u0026amp;= \\cos^2(x)(1 - \\frac{\\sin(2x)}{\\cos^2(x)}) \\\\ \u0026amp;= \\cos^2(x)(1 - \\frac{2\\sin(x)cos(x)}{\\cos^2(x)}) \\\\ \u0026amp;= \\cos^2(x)(1 - 2\\tan(x)) \\end{aligned} $$\n然后考虑 \\( \\tan(x) = -\\frac{3}{4} = \\frac{\\sin(x)}{\\cos(x)} \\)\n有以下情况：\n\\( \\sqrt{(-3)^2 + 4^2} = 5 \\) 或 \\( \\sqrt{3^2 + (-4)^2} = 5 \\) \\( \\sin(x) \\) 为负或者 \\( \\cos(x) \\) 为负 既有 \\( \\cos(x) = -\\frac{4}{5} \\) 或者 \\( \\cos(x) = \\frac{4}{5} \\)\n这并不影响到 \\( \\cos^2(x) \\) 的值，所以有\n$$ \\begin{aligned} \\cos^2(x) - \\sin(2x) \u0026amp;= \\cos^2(x)(1 - 2\\tan(x)) \\ \u0026amp;= \\frac{16}{25} \\cdot [1 - 2 \\cdot (-\\frac{3}{4})] \\ \u0026amp;= \\frac{8}{5} \\end{aligned} $$\n(2) 求 \\( f(x) + 4\\cos(2A + \\frac{\\pi}{6}) (x \\in [0, \\frac{\\pi}{3}]) \\) 的取值范围\n先求角 \\( A \\).\n由正弦定理知：\\( \\sin(A) = \\frac{a\\sin(B)}{b} = \\frac{\\sqrt{3}\\frac{\\sqrt{6}}{3}}{2} = \\frac{\\sqrt{2}}{2} \\rightarrow A = \\frac{\\pi}{4} \\)，所以 \\( \\cos(2A + \\frac{\\pi}{6}) = \\cos(\\frac{\\pi}{2} + \\frac{\\pi}{6}) = -\\sin(\\frac{\\pi}{6}) = -\\frac{1}{2} \\)。\n令 \\( \\varphi (x) = f(x) - 2 (x \\in [0, \\frac{\\pi}{3}]) \\)\n由题目条件知： \\( f(x) = 2cos^2(x) + sin(2x) + \\frac{1}{2} \\)\n$$ \\begin{aligned} f\u0026rsquo;(x) \u0026amp;= -4\\cos(x)\\sin(x) + 2\\cos(2x) \\ \u0026amp;= 2(\\cos(2x) - \\sin(2x)) \\ \u0026amp;= 2\\sqrt{2}\\sin(-2x + \\frac{\\pi}{4}) \\end{aligned} $$\n令 \\( f\u0026rsquo;(x) = 0 \\)，则可得到 \\( x = \\frac{\\pi}{8} + k\\pi (k = 0,1,2\u0026hellip;) \\)\n\\( \\because x \\in [0, \\frac{\\pi}{3}], \\therefore x = \\frac{\\pi}{8} \\)\n① \\( f\u0026rsquo;(x) \\) 在 \\( x \\in [0, \\frac{\\pi}{8}) \\) 恒大于 \\( 0 \\)，原函数 \\( f(x) \\) 在 \\( x \\in [0, \\frac{\\pi}{8}) \\) 内单调递增；\\( f\u0026rsquo;(x) \\) 在 \\( x \\in (\\frac{\\pi}{8}, \\frac{\\pi}{3}] \\) 恒小于 \\( 0 \\)，原函数 \\( f(x) \\) 在 \\( x \\in (\\frac{\\pi}{8}, \\frac{\\pi}{3}] \\) 内单调递减，所以 \\( x = \\frac{\\pi}{8} \\) 为 \\( f(x) \\) 在 \\( x \\in [0, \\frac{\\pi}{3}) \\) 内的唯一一个最大值.\n② 因为 \\( f(x) \\) 在 \\( (\\frac{\\pi}{8}, \\frac{\\pi}{3}] \\) 上单调递减，又 \\( f(0) \u0026gt; f(\\frac{\\pi}{3}) \\)，所以 \\( f(\\frac{\\pi}{3}) \\) 是 \\( f(x) \\) 在 \\( x \\in [0, \\frac{\\pi}{3}) \\) 内的唯一一个最小值.\n可以借助工具来画出函数图看一看是否正确：\n由计算可得 \\( f(\\frac{\\pi}{8}) = \\frac{3}{2} + \\sqrt{2}, f(\\frac{\\pi}{3}) = 1 + \\frac{\\sqrt{3}}{2} \\)\n于是\n$$ \\begin{aligned} max(\\varphi(x)) \u0026amp;= f(\\frac{\\pi}{8}) - 2 = \\sqrt{2} - \\frac{1}{2} \\ min(\\varphi(x)) \u0026amp;= f(\\frac{\\pi}{3}) - 2 = \\frac{\\sqrt{3}}{2} - 1 \\end{aligned} $$\n2.(2019 全国卷Ⅲ 理数）已知函数 \\( f(x) = 2x^3 - ax^2 + b \\).\n(1) 讨论 \\( f(x) \\) 的单调性;\n(2) 是否存在 \\( a, b \\)，使得 \\( f(x) \\) 在区间 \\( [0, 1] \\) 的最小值为 \\( -1 \\) 且最大值为 \\( 1 \\)？若存在，求出 \\( a, b \\) 的所有值；若不存在，说明理由。\n虽然是比较简单的题，不过还是给出题解吧：\n(1) 显然，该题这类含未知量的函数要讨论单调性，利用求导工具最便利，对 \\( f(x) \\) 求导有：\\( f\u0026rsquo;(x) = 6x^2 - ax \\). 现在我们就只需要对 \\( a \\) 分类讨论函数的单调区间了。\n① 当 \\( a \u0026lt; 0 \\)\n若 \\( f\u0026rsquo;(x) \\leq 0 \\)，有 \\( \\begin{aligned} 6x^2 - 2ax \u0026amp;\\leq 0 \\\\ 2x \\cdot (3x - a) \u0026amp;\\leq 0 \\end{aligned} \\)，解不等式得到：\\( \\frac{a}{3} \\leq x \\leq 0 \\)（注意 \\( a \u0026lt; 0 \\)），即 \\( f\u0026rsquo;(x) \\ 在 \\ [\\frac{a}{3}, 0] \\) 上小于 \\( 0 \\)，而原函数 \\( f(x) \\) 在 \\( [\\frac{a}{3}, 0] \\) 上单调递减. 若 \\( f\u0026rsquo;(x) \u0026gt; 0 \\)，由 \\( \\begin{aligned} 6x^2 - 2ax \u0026amp;\u0026gt; 0 \\ 2x \\cdot (3x - a) \u0026amp;\u0026gt; 0 \\end{aligned} \\)，得：\\( x \u0026lt; \\frac{a}{3}, x \u0026gt; 0 \\)，即 \\( f\u0026rsquo;(x) \\) 在 \\( (-\\infty, \\frac{a}{3}) \\vee (0, +\\infty) \\) 上大于 \\( 0 \\)，而原函数 \\( f(x) \\) 在 \\( (-\\infty, \\frac{a}{3}) \\vee (0, +\\infty) \\) 上单调递增. ② 当 \\( a = 0 \\)\n\\( a = 0 \\)，所以有 \\( f\u0026rsquo;(x) = 6x^2 \\geq 0 \\)，因此原函数 \\( f(x) \\) 在 \\( (-\\infty, +\\infty) \\) 上单调递增. ③ 当 \\( a \u0026gt; 0 \\)\n若 \\( f\u0026rsquo;(x) \\leq 0 \\)，由 \\( \\begin{aligned} 6x^2 - 2ax \u0026amp;\\leq 0 \\\\ 2x \\cdot (3x - a) \u0026amp;\\leq 0 \\end{aligned} \\)，得：\\( 0 \\leq x \\leq \\frac{a}{3} \\)，即 \\( f\u0026rsquo;(x) \\) 在 \\( [0, \\frac{a}{3}] \\) 上小于 \\( 0 \\)，而原函数 \\( f(x) \\) 在 \\( [0, \\frac{a}{3}] \\) 上单调递减. 若 \\( f\u0026rsquo;(x) \u0026gt; 0 \\)，由 \\( \\begin{aligned} 6x^2 - 2ax \u0026amp;\u0026gt; 0 \\\\ 2x \\cdot (3x - a) \u0026amp;\u0026gt; 0 \\end{aligned} \\)，得：\\( x \u0026lt; 0 或 x \u0026gt; \\frac{a}{3} \\) ，即 \\( f\u0026rsquo;(x) \\ 在 \\ (-\\infty, 0) \\vee (\\frac{a}{3}, +\\infty) \\) 上大于 \\( 0 \\)，而原函数 \\( f(x) \\) 在 \\( (-\\infty, 0) \\vee (\\frac{a}{3}, +\\infty) \\) 上单调递增. 讨论完毕。\n(2) 只需要利用 (1) 讨论得结果即可证明。\n① 当 \\( a \u0026lt; 0 \\)，由 (1) 问知 \\( f(x) \\) 在 \\( (0, +\\infty) \\) 上单调递增，那么函数 \\( f(x) \\) 可在端点处取得最小值和最大值，即\n$$ \\begin{aligned} min(f(x)) \u0026amp;= b = -1 \\quad when \\ x = 0 \\\\ max(f(x)) \u0026amp;= 2 - a + b \\quad when \\ x = 1 \\end{aligned} $$\n由 \\( b = -1, max(f(x)) = f(1) = 2 - a - 1 = 1 - a \\)，又因为 \\( a \u0026lt; 0 \\)，所以 \\( f(1) \u0026gt; 1 \\)，这与题目条件矛盾。\n② 当 \\( a = 0 \\)，由 (1) 问知 \\( f(x) \\) 在 \\( (-\\infty, +\\infty) \\) 上单调递增，那么函数 \\( f(x) \\) 可在端点处取得最小值和最大值，即\n$$ \\begin{aligned} min(f(x)) \u0026amp;= b = -1 \\quad when \\ x = 0 \\\\ max(f(x)) \u0026amp;= 2 + b \\quad when \\ x = 1 \\end{aligned} $$\n由 \\( b = -1, max(f(x)) = f(1) = 2 - 1 = 1 \\)，正好满足题目条件，故存在 \\( a = 0, b = -1 \\) 使得函数 \\( f(x) \\) 在区间 \\( [0, 1] \\) 上得最小值为 \\( -1 \\)，最大值为 \\( 1 \\)。\n③ 当 \\( a \u0026gt; 0 \\)，由 (1) 问知 \\( f(x) \\) 在 \\( [0, \\frac{a}{3}] \\) 上单调递减，那么函数 \\( f(x) \\) 可在 \\( x = 0 \\) 处取得最大值，\\( x = \\frac{a}{3} \\) 处取得最小值。\n当 \\( 0 \u0026lt; a \u0026lt; 3 \\) 时，\\( f(x) \\) 在 \\( [0, 1] \\) 上有 \\( \\begin{aligned} max(f(x)) \u0026amp;= b = 1 \\quad when \\ x = 0 \\\\ min(f(x)) \u0026amp;= 2(\\frac{a}{3})^3 - a(\\frac{a}{3})^2 + b \\quad when \\ x = \\frac{a}{3}\\end{aligned} \\)，由 \\( b = 1, 2(\\frac{a}{3})^3 - a(\\frac{a}{3})^2 + 1 = -1 \\Rightarrow a = 3 \\cdot 2^{\\frac{1}{3}} \\)，即，取 \\( a = 3 \\cdot 2^{\\frac{1}{3}} \u0026gt; 3 \\)，故矛盾。 当 \\( a \\geq 3 \\) 时，\\( f(x) \\) 在 \\( [0, 1] \\) 上有 \\( \\begin{aligned} max(f(x)) \u0026amp;= b = 1 \\quad when \\ x = 0 \\\\ min(f(x)) \u0026amp;= 2 - a + b \\quad when \\ x = 1\\end{aligned} \\)，由 \\( b = 1 \\)，有 \\( f(1) = 2 - a + 1 = -1 \\Rightarrow a = 4 \\)，满足题目条件。 故当 \\( a = 0, b = -1\\) 或 \\( a = 4, b = 1 \\) 时，\\( f(x) \\) 在 \\( [0, 1] \\) 上取得最小值和最大值。\n证毕。\n","date":"2018-09-05","externalUrl":null,"permalink":"/docs/2018-09-05-math-derivative/","section":"Docs","summary":"","title":"数学-导数篇（持续更新）","type":"docs"},{"content":"\r这里存放一些积分方程题的题解。\n题目 #\r1.求 \\( \\int_{0}^{\\frac{\\pi}{4}} x \\ \\prod cos(\\frac{x}{2^k}) dx \\) (from MIT 2015 Integration Bee) (这个题是在youtube上看到的，解法也是视频中给出的)\n题解：\n注意到 \\( \\prod cos(\\frac{x}{2^k}) = cos(\\frac{x}{2}) \\cdot cos(\\frac{x}{2^2}) \\cdot \\cdot \\cdot \\)\n利用 \\( sin(2x) = 2sin(x)cos(x) \\Rightarrow cos(x) = \\frac{sin(2x)}{2sin(x)} \\)\n将上面第一个等式最右边按照上式规则写出来，有：\n$$ cos(\\frac{x}{2}) \\cdot cos(\\frac{x}{2^2}) \\cdot cos(\\frac{x}{2^2}) \\cdots = \\frac{sin(x)}{2sin(\\frac{x}{2})} \\cdot \\frac{sin(\\frac{x}{2})}{2sin(\\frac{x}{2^2})} \\cdot \\frac{sin(\\frac{x}{2^2})}{2sin(\\frac{x}{2^3})} \\cdots $$\n观察等式右边发现，除第一项分子以外，后一项的分子总是能和前一项的分母约掉，于是我们可以得到这样的形式：\n$$ \\frac{sin(x)}{2^k sin(\\frac{x}{2^k})}, k \\rightarrow \\infty $$\n于是，求极限：\n$$ \\begin{aligned} \\lim_{k \\rightarrow \\infty} \\frac{sin(x)}{2^k sin(\\frac{x}{2^k})} \u0026amp;= sin(x) \\lim_{k \\rightarrow \\infty} \\frac{1}{2^k sin(\\frac{x}{2^k})} \\\\ \u0026amp;= sin(x) \\lim_{k \\rightarrow \\infty} \\frac{1}{x\\frac{sin(\\frac{x}{2^k})}{\\frac{x}{2^k}}} \\\\ \u0026amp;= sin(x) \\lim_{k \\rightarrow \\infty} \\frac{1}{x \\cdot 1} \\\\ \u0026amp;= \\frac{sin(x)}{x} \\end{aligned} $$\n所以，积分方程中的那一坨 \\( \\prod cos(\\frac{x}{2^k}) = \\frac{sin(x)}{x} \\)\n带入积分方程并计算：\n$$ \\begin{aligned} \\int_{0}^{\\frac{\\pi}{4}} x \\ \\prod cos(\\frac{x}{2^k}) dx \u0026amp;= \\int_{0}^{\\frac{\\pi}{4}} x \\ \\frac{sin(x)}{x} dx \\\\ \u0026amp;= \\int_{0}^{\\frac{\\pi}{4}} sin(x) dx \\\\ \u0026amp;= -cos(x)|{0}^{\\frac{\\pi}{4}} \\\\ \u0026amp;= -cos(\\frac{\\pi}{4}) - (-cos(0)) \\\\ \u0026amp;= 1 - \\frac{\\sqrt{2}}{2} \\end{aligned} $$\n2.求 \\( \\int_{0}^{\\infty} x \\ e^{1-x} + \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx \\) 的值（解法参考同上）\n题解：\n$$ \\int_{0}^{\\infty} x \\ e^{1-x} + \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx = \\int_{0}^{\\infty} x \\ e^{1-x} dx + \\int_{0}^{\\infty} \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx $$\n等式右边第一项积分很好算：\n$$ \\begin{aligned} \\int_{0}^{\\infty} x \\ e^{1-x} dx \u0026amp;= e\\int_{0}^{\\infty} x \\ e^{-x} \\\\ \u0026amp;= e(-x \\ e^{-x}|0^{\\infty} - e^{-x}|0^{\\infty}) \\\\ \u0026amp;= e[-e^{-x}(1+x)|{0}^{\\infty}] \\\\ \u0026amp;= e \\end{aligned} $$\n现在来计算一下等式右边第二项积分：\n令 \\( S = \\int_{0}^{\\infty} \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx \\)\n我们来看一下 \\( f(x) = \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} \\) 的函数图：\n然后写几项看看，我们会发现可以用简单的级数形式来表示：\n$$ \\begin{aligned} S \u0026amp;= 0 \\cdot 1 + 1 \\cdot 1 + 2 \\cdot \\frac{1}{e} + 3 \\cdot \\frac{1}{e^2} + \\cdots \\\\ \u0026amp;= 1 + \\frac{2}{e} + \\frac{3}{e^2} + \\cdots \\\\ \u0026amp;= \\sum_{x=0}^{\\infty} \\frac{x}{e^{x-1}} \\end{aligned} $$\n现在来求这个级数的和：\n$$ \\begin{aligned} S \u0026amp;= 1 + \\frac{2}{e} + \\frac{3}{e^2} + \\cdots \\quad (1) \\\\ \\frac{1}{e} \\cdot S \u0026amp;= \\frac{1}{e} + \\frac{2}{e^2} + \\frac{3}{e^3} + \\cdots \\quad (2) \\end{aligned} $$\n\\( (1) - (2) \\)式有：\n$$ \\begin{aligned} S - \\frac{1}{e} \\cdot S \u0026amp;= 1 + \\frac{1}{e} + \\frac{1}{e^2} + \\frac{1}{e^3} + \\cdots \\\\ \u0026amp;= \\sum_{n=0}^{\\infty} (\\frac{1}{e})^n \\\\ (1-\\frac{1}{e})S \u0026amp;= \\frac{1}{1-\\frac{1}{e}} \\\\ \\Rightarrow S \u0026amp;= \\frac{1}{(1-\\frac{1}{e})^2} \\end{aligned} $$\n回到原题 \\( \\int_{0}^{\\infty} x \\ e^{1-x} + \\left \\lfloor x \\right \\rfloor e^{1-\\left \\lfloor x \\right \\rfloor} dx = e + \\frac{1}{(1-\\frac{1}{e})^2} \\)\n","date":"2018-09-03","externalUrl":null,"permalink":"/docs/2018-09-03-integral-equation/","section":"Docs","summary":"","title":"高等数学-积分方程篇（持续更新）","type":"docs"},{"content":"\r这里是关于向量运算的题目题解，题目质量大概参差不齐。\n向量在现代数学和物理中有着很重要的作用，指的是一种具有大小和方向的量。又叫做矢量(\rVector-wikipedia)\n题目 #\r1.已知向量 \\( \\vec{OA}, \\vec{OB} \\) 满足 \\( |OA| = |OB| = 1, \\vec{OA} \\cdot \\vec{OB} = 0, \\vec{OC} = \\lambda \\ \\vec{OA} + \\mu \\ \\vec{OB} (\\lambda ,\\mu \\in \\mathbb{R}) \\). 若 \\( M \\) 为 \\( AB \\) 的中点，并且 \\( |\\vec{MC}| = 1 \\)，则点 \\( (\\lambda , \\mu) \\) 在 ( )\nA. 以 \\( (-\\frac{1}{2}, \\frac{1}{2}) \\) 为圆心，半径为 \\( 1 \\) 的圆上.\nB. 以 \\( (\\frac{1}{2}, -\\frac{1}{2}) \\) 为圆心，半径为 \\( 1 \\) 的圆上.\nC. 以 \\( (-\\frac{1}{2}, -\\frac{1}{2}) \\) 为圆心，半径为 \\( 1 \\) 的圆上.\nD. 以 \\( (\\frac{1}{2}, \\frac{1}{2}) \\) 为圆心，半径为 \\( 1 \\) 的圆上.\n题解：\n假设 \\( A \\) 点的坐标为 \\( (x_0, y_0), B \\) 点的坐标为 \\( (x_1, y_1) \\).\n由题目前2个条件知：\n$$ x_0 ^2 + y_0 ^2 = 1, x_1 ^2 + y_1 ^2 = 1, x_0 \\ x_1 + y_0 \\ y_1 = 0 $$\n将 \\( A,B \\) 点坐标带入第3个条件：\\( \\vec{OC} = \\lambda \\ \\vec{OA} + \\mu \\ \\vec{OB} (\\lambda ,\\mu \\in \\mathbb{R}) \\)\n于是求出 \\( C \\) 的坐标：\\( (\\lambda \\ x_0 + \\mu \\ x_1, \\lambda \\ y_0 + \\mu \\ y_1) \\)\n\\( M \\) 是 \\( AB \\) 的中点，所以得到 \\( M \\) 的坐标为：\\( (\\frac{x_1 - x_0}{2}, \\frac{y_1 - y_0}{2}) \\)\n又因为 \\( |\\vec{MC}| = 1 \\), 把上面 \\( M, C \\) 的坐标代入进行计算并化简，最终可得：\\( (\\lambda + \\frac{1}{2})^2 + (\\mu - \\frac{1}{2})^2 = 1 \\)\n所以，选 \\( B \\).\n","date":"2018-09-02","externalUrl":null,"permalink":"/docs/2018-09-02-math-vector/","section":"Docs","summary":"","title":"高中数学-向量篇（持续更新）","type":"docs"},{"content":"\rKruskal算法可用来求解最小生成树(minimum-spanning-tree, MST)问题，还可以用来生成迷宫。\n算法分析 #\r算法先要将 \\( G(V, E) \\) 的集合 \\( E \\) 按权重 \\( \\Omega \\) 由小到大排序，然后还利用了不相交集中的find()(这里使用的是带路径压缩功能的) 和union()(这里函数名使用marge()) 函数，find()用于判断是否连通，如果连通则不能构成MST，反之则加入到MST的集合中，并调用union()函数将顶点连通。\n时间复杂度 #\r$$ O(E lg V) $$\n空间复杂度 #\r$$ O(V + E) $$\n算法实现 #\r#include \u0026#34;stdafx.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int N = 10010; int p[N]; vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; graph; void init(int V, int E) { for (int i = 1; i \u0026lt;= V; i++) p[i] = i; for (int i = 0; i \u0026lt; E; i++) { int w, s, e; cin \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; graph.push_back(pair\u0026lt;int, pair\u0026lt;int ,int\u0026gt;\u0026gt;(w, pair\u0026lt;int, int\u0026gt;(s, e))); } sort(graph.begin(), graph.end()); for (auto e : graph) cout \u0026lt;\u0026lt; e.first \u0026lt;\u0026lt; e.second.first \u0026lt;\u0026lt; e.second.second \u0026lt;\u0026lt; endl; } int find(int x) { if (x != p[x])\tp[x] = find(p[x]); return p[x]; } void marge(int x, int y) { int r = find(x), t = find(y); if (r != t)\tp[r] = t; } vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; kruskal(int V, int E) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; msts; init(V, E); for (vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt;::iterator i = graph.begin(); i != graph.end(); i++) { if (find(i-\u0026gt;second.first) != find(i-\u0026gt;second.second)) { msts.push_back(i-\u0026gt;second); marge(i-\u0026gt;second.first, i-\u0026gt;second.second); } } return msts; } int main(int argc, char **argv) { int V, E; cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; es = kruskal(V, E); for (auto e : es) cout \u0026lt;\u0026lt; e.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e.second \u0026lt;\u0026lt; endl; return 0; } 参考 #\rKruskal\u0026rsquo;s algorithm - wikipedia Maze generation algorithm - wikipedia CLRS \\( P_{366} \\) 伪代码 ","date":"2018-08-29","externalUrl":null,"permalink":"/docs/2018-08-29-kruskal-s-algorithm/","section":"Docs","summary":"","title":"Kruskal's algorithm","type":"docs"},{"content":"\rTarjan算法可以用来求有向图的强连通分量个数。算法由Robert Tarjan于1972年发明的。\n算法分析 #\rTarjan算法的主要算法部分也是 dfs，但利用了重要的额外信息。下面详细分析了算法的执行过程。\n强连通子图的重要特点：对于强连通子图，有一个特定的事实就是，该子图一定形成环，那么从该子图中任意点出发，总能回到出发点。\n基于上面这一点，Tarjan算法通过维护两个存放顶点访问顺序（时间）的数组。如果子图形成环，则将处于环中的每一个顶点的访问顺序置为该环的出发点的访问时间，以表明他们是一个强连通子图。可能你会怀疑进入环后，不会只在环中遍历，可能会跳到其他顶点上。实际上这担心是多余，因为图结构使用邻接链表表示，强连通子图使用dfs进行遍历时，只会寻找与当前顶点连接的出度顶点，而形成环的子图中，会很合理的按顺序遍历完。对于孤立点，则自身就是一个环，即强连通分量。\n这就是Tarjan算法的思想 —— 维护两个存储访问顺序的数组，然后将形成环的节点的访问时间都置为该强连通子图的出发点的访问时间。\n通过下图可以更直观的理解Tarjan算法的执行过程（图来自维基）：\n时间复杂度 #\r最坏情况是图G的强连通子图就是其本身（这样的图称为强连通图），这时 dfs 的消费为 \\( O(|V| + |E|) \\)，最后一次 dfs 的while循环再消费掉 \\( O(V) \\)，所以 dfs() 最坏情况为 \\( O(|V| + |E|) \\)。最后 tarjan() 的总消耗为 \\( O (V^2) \\)。\n空间复杂度 #\r显然为 \\( O(V) \\)。\n算法实现 #\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;minmax.h\u0026gt; using namespace std; const int N = 10010; list\u0026lt;int\u0026gt; *adj; stack\u0026lt;int\u0026gt; s; int vis[N], low[N]; bool onstack[N]; int times = 0, scc = 0; void addEdge(int u, int v) { adj[u].push_back(v); } void dfs(int u) { vis[u] = low[u] = times++; s.push(u); onstack[u] = true; for (list\u0026lt;int\u0026gt;::iterator i = adj[u].begin(); i != adj[u].end(); ++i) { int v = *i; if (vis[v] == -1) { dfs(v); low[u] = min(low[u], low[v]); } else if (onstack[v] == true) low[u] = min(low[u], vis[v]); } if (low[u] == vis[u]) { while (s.top() != u) { int w = s.top(); cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39; \u0026#39;; onstack[w] = false; s.pop(); } int w = s.top(); cout \u0026lt;\u0026lt; w \u0026lt;\u0026lt; endl; onstack[w] = false; s.pop(); scc++; } } void tarjan(int V, int E) { adj = new list\u0026lt;int\u0026gt;[V + 1]; list\u0026lt;int\u0026gt; v; for (int i = 1; i \u0026lt;= V; i++) { vis[i] = low[i] = -1; onstack[i] = false; } for (int i = 1; i \u0026lt;= E; i++) { int u, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; w; adj[u].push_back(w); } for (int i = 1; i \u0026lt;= V; i++) if (vis[i] == -1) dfs(i); cout \u0026lt;\u0026lt; \u0026#34;该图的强连通分量个数为：\u0026#34; \u0026lt;\u0026lt; scc \u0026lt;\u0026lt; endl; } int main(int argc, char **argv) { int V, E; cin \u0026gt;\u0026gt; V \u0026gt;\u0026gt; E; tarjan(V, E); return 0; } 代码中 dfs() 函数的 for 循环后面的部分用来输出所有强连通子图中的顶点，并求出强连通分量个数。\n下面以前面wiki图为例测试一下算法。\n算法测试结果：\n3 2 1 7 6 5 4 8 该图的强连通分量个数为：4 参考 #\rStrongly connected components algorithm - wikipedia Strongly connected components algorithm ","date":"2018-08-27","externalUrl":null,"permalink":"/docs/2018-08-27-tarjan-s-algorithm/","section":"Docs","summary":"","title":"Tarjan's algorithm","type":"docs"},{"content":"\r生活中许多实际应用都需要使用有向无环图来指明事件的优先次序。比如我们早上起床穿衣洗漱的次序等。 借用《算法导论》中举的例子，我制作了一张相同的图来描述这个概念：\n上图描述了，一个教授每天早上起床穿衣所发生的事件的次序图。教授必须先穿上某些衣物，才能再穿其他衣服（比如先穿上袜子才能再穿鞋子）。有些服饰则无先后次序，可以按任意顺序穿上。\n如果我们按照教授每件衣物穿好时的时间排序，然后得到逆序，我们就可以看到教授的穿戴顺序，这样一个顺序就是拓扑排序。所以，拓扑排序的概念很简单。\n但需要注意的是这样的事情必须发生在有向无环图中，假如有环，我们可以想象，教授这一些列动作是不可能完成的。\n算法思路 #\r如上面所说，我们的目的就是记录每个物件穿戴完成的时间，也就是在一个有向无环图中记录遍历过的每一个顶点v的离开时间，这只需要额外的一个 \\( O(V) \\) 空间消耗。\n算法实现 #\r#include \u0026lt;bits/stdc++.h\u0026gt; #define INF 0x3f3f int visied[INF], graph[INF][INF]; int d[INF], f[INF]; // 访问前的时间，访问后的时间，记录整个任务过程的时间线 int V, t = 0; // t表示时间 void dfs(int v) { t += 1; d[v] = t; visied[v] = 1; for (int i = 1; i \u0026lt;= V; i++) if (!visied[i] \u0026amp;\u0026amp; graph[v][i]) dfs(i); t += 1; f[v] = t; } void topological_sort() { // sort to array f } int main() { int E, s, e; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;V, \u0026amp;E); memset(visied, 0, sizeof(visied)); memset(d, 0, sizeof(d)); memset(f, 0, sizeof(f)); for (int i = 0; i \u0026lt; E; i++) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;s, \u0026amp;e); graph[s][e] = 1; } for (int i = 1; i \u0026lt;= V; i++) if (!visied[i]) dfs(i); for (int i = 1; i \u0026lt;= V; i++) printf(\u0026#34;%d: %d\\n\u0026#34;, i, f[i]); return 0; } 测试用例如图：\n输出:\n1: 10 2: 12 3: 9 4: 4 5: 8 6: 16 7: 15 8: 7 按时间逆序排序，看看顶点访问顺序：\n6 7 2 1 3 8 5 4 结合前面的拓扑排序概念，可以证明这个排序是合理的。\n时间复杂度分析 #\r这是用邻接矩阵表示法实现的，所以排序时间复杂度为 \\( O(V lg V) \\)，如果节点并不多可以使用一些空间换时间的排序手段降低排序时间。\n参考 #\r算法导论 ","date":"2018-08-24","externalUrl":null,"permalink":"/docs/2018-08-24-topological-sort/","section":"Docs","summary":"","title":"拓扑排序","type":"docs"},{"content":"\r该算法可以用来求解一个有向图的强连通分量。\n算法解析 #\r什么是强连通分量？\n先说说强连通图：在有向图 \\( G \\) 中，如果任意 \\( u,v \\) 两顶点间连通，则称 \\( (u,v) \\) 强连通，则图 \\( G \\) 的一个强连通图，强连通图的极大强连通子图（强连通分量）就是其本身。\n根据上面的说法，如果向图 \\( G \\) 中添加 \\( x \\) 个额外节点，使得有向图 \\( G \\) 不再是强连通图，则存在强连通分量。\n下面考虑下图\n（不知道怎么用graphviz把节点位置弄得更好看一点，将就着看吧）\n手工字符版：\n1 \u0026lt;--\u0026gt; 2 --\u0026gt; 3\r↖ |\r\\ ↓\r4 该图的强连通分量个数为： \\( 1 \\) ，因为任意两顶点都能相互到达。\n再举例：\n1 \u0026lt;--\u0026gt; 2 --\u0026gt; 3\r|\r↓\r4 该图的强连通分量个数为：\\( 3 \\)，图中\\( (1,2)、(3)、(4) \\)都是强连通分量。\n明白了强连通分量后，再来看算法。\n以\r为例，我们得到它的邻接矩阵：\n它的逆图及邻接矩阵：\n算法首先对原图进行 \\( DFS \\) 遍历，然后将所有顶点加入到栈中，然后再将栈中的顶点倒出，从倒出的顶点对逆图进行遍历，如果任意两顶点相连通，则 \\( DFS2 \\) 只调用一次就可以遍历逆图中所有顶点。如果出现不相互连通的顶点，则对逆图的遍历就会在中途中止，并通过栈中倒出的顶点来遍历完所有顶点。\n现在来考虑核心算法部分的最坏情况的时间复杂度。\n最坏情况时，显然所有顶点都是孤立的，算法开始时调用memset()，耗费 \\( O(V) \\)，接下来调用DFS1()，无论原图是否为强连通图，DFS1()都将耗费 \\( O(V^2) \\)，然后再次调用memset()，耗费 \\( O(V) \\)，最后while()循环在最坏情况下将对每个顶点调用一次DFS2()，耗费 \\( O(V^2) \\)。所以算法的时间总消耗为 \\( O(V + V^2 + V + V^2) = O(V^2) \\)，这是使用邻接矩阵表示图时的时间复杂度。\n使用邻接链表表示图时的时间复杂度为 \\( O(V + E) \\) 的线性时间。\n算法实现 #\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int map[511][511]; int nmap[511][511]; int visited[501]; stack\u0026lt;int\u0026gt; S; int N; void DFS1(int v) { visited[v] = 1; for (int i = 1; i \u0026lt;= N; i++) if (!visited[i] \u0026amp;\u0026amp; map[v][i]) DFS1(i); S.push(v); } void DFS2(int v) { visited[v] = 1; for (int i = 1; i \u0026lt;= N; i++) if (!visited[i] \u0026amp;\u0026amp; nmap[v][i]) DFS2(i); } int kosaraju() { memset(visited, 0, sizeof(visited)); for (int i = 1; i \u0026lt;= N; i++) if (!visited[i]) DFS1(i); int t = 0; memset(visited, 0, sizeof(visited)); while (!S.empty()) { int v = S.top(); S.pop(); // printf(\u0026#34;|%d|\u0026#34;, v); if (!visited[v]) { t++; DFS2(v); } } return t; } int main() { int M, s, e; scanf_s(\u0026#34;%d %d\u0026#34;, \u0026amp;N, \u0026amp;M); // 顶点及边个数 memset(map, 0, sizeof(map)); memset(nmap, 0, sizeof(nmap)); for (int i = 0; i \u0026lt; M; i++) { scanf_s(\u0026#34;%d %d\u0026#34;, \u0026amp;s, \u0026amp;e); map[s][e] = 1; nmap[e][s] = 1; } printf(\u0026#34;\\n%d\\n\u0026#34;, kosaraju()); return 0; } 参考 #\rKosaraju\u0026rsquo;s algorithm - wikipedia ","date":"2018-08-17","externalUrl":null,"permalink":"/docs/2018-08-17-kosaraju-s-algorithm/","section":"Docs","summary":"","title":"Kosaraju's algorithm","type":"docs"},{"content":"\r牛顿法也是数值分析中很常见的算法了。嘛，网上对它的各种介绍也很多，但还是稍微说一下这个算法。\n对于方程 \\( f(x) = 0 \\)，初中的时候大部分的方程我们都可以使用求根公式解决，但实际上有许多方程我们很难求出它的根，于是只能用数值分析方法来逼近根值。基本原理:设 \\( y=f(x) \\) 在 \\( x \\in [a,b] \\) 上连续，如果有 \\( f(a)f(b) \u0026lt; 0 \\)，则 \\( f(x), x \\in (a, b) \\) 一定过零点（费马引理），那么 \\( f(x) \\) 在点 \\( x0, (a \u0026lt; x_0 \u0026lt; b)\\) 处的切线方程也过零点，根据 \\( f(x) \\) 曲线的类型：递增、递减、凸或凹，我们会发现起点的选择对于切线随着点向根方向移动时的效率也是不同的。\n比如：若 \\( x \\in [a, b], f(a) \u0026lt; 0, f(b) \u0026gt; 0, f\u0026rsquo;\u0026rsquo;(x) \u0026lt; 0 \\) 时，起点应从 \\( a ) 点开始迭代效率会更高，即考察 \\( f(a) \\) 与 \\( f\u0026rsquo;\u0026rsquo;(x) \\) 是否同号，如果同号，则 \\( a \\) 点为起点，否则 \\( b \\) 点为起点。\n总之，根据 \\( y = f(x) \\) 在 \\( x_0 \\) 处求出切线方程有：\n$$ f(x) - f(x_0) = f\u0026rsquo;(x_0)(x - x_0) $$\n由于 \\( f(x) = 0 \\)，所以有：\n$$ x_1 = x_0 - \\frac{f(x_0)}{f\u0026rsquo;(x_0)} $$\n再在点 \\( (x_1, f(x_1)) \\) 作切线，可得根得近似值 \\( x_2 \\)。如此反复进行，一般的，在点 \\( (x_{n-1}, f(x_{n-1})) \\) 作切线，最终可得到迭代方程：\n$$ x_{n+1} = x_n - \\frac{f(x_n)}{f\u0026rsquo;(x_n)} $$\n算法实现 #\rC++:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;functional\u0026gt; const double h = 1e-5; auto square(double x) -\u0026gt; double const { return x * x; } auto cube(double x) -\u0026gt; double const { return x * x * x; } template\u0026lt;class Fn_Ty\u0026gt; auto partial_derivative(Fn_Ty g) { auto a = [g](const auto\u0026amp; vec, size_t i) { auto components = vec; components[i] += h; return (g(components) - g(vec)) / h; }; return a; } template\u0026lt;class Fn_Ty, class Arg\u0026gt; auto fixed_point(Fn_Ty g, Arg first_guess) { auto close_enough = [](auto v1, auto v2) { return (std::abs(v1 - v2) \u0026lt; 1e-5); }; auto try_again = [g, close_enough](auto guess, auto\u0026amp; try_ref) { auto next = g(guess); if (close_enough(guess, next)) return next; else return try_ref(next, try_ref); }; return try_again(first_guess, try_again); } template\u0026lt;class Fn_Ty\u0026gt; auto deriv(Fn_Ty g) { auto a = [g](auto x) { return (g(x + h) - g(x)) / h; }; return a; } template\u0026lt;class Fn_Ty\u0026gt; auto newton_transform(Fn_Ty g) { auto a = [g](auto x) { return x - (g(x) / deriv(g)(x)); }; return a; } template\u0026lt;class Fn_Ty, class Arg\u0026gt; auto newton_method(Fn_Ty g, Arg guess) { return fixed_point(newton_transform(g), guess); } 示例 #\r求 \\( f(x) = \\cos(x) - x^3 = 0 \\) 的零点。\nint main() { std::cout \u0026lt;\u0026lt; newton_method([](double x) { return std::cos(x) - cube(x); }, 1.0) \u0026lt;\u0026lt; std::endl; return 0; } 输出：0.865474\n相关内容 #\r牛顿法开方 #\r关于牛顿法开方（或任意次方）算法，强烈推荐看看这个回答：\r果壳网\n简单提一下需要注意得地方：求 \\( \\sqrt{2} \\) 时，考虑有 \\( f(x) = x^2 - a = 0 \\)，其中 \\( a = 2 \\)。\n开方代码实现：\ndouble m_sqrt(double x) { auto a = [x](auto y) { return square(y) - x; }; return newton_method(a, 1.0); } int main() { std::cout \u0026lt;\u0026lt; m_sqrt(2.0) \u0026lt;\u0026lt; std::endl; return 0; } 极值 #\r$$ x_{i+1} = x_i - \\frac{f\u0026rsquo;(x_i)}{f\u0026rsquo;\u0026rsquo;(x_i)} $$\n代码实现：\ntemplate\u0026lt;class Fn_Ty\u0026gt; auto minimization(Fn_Ty g) { return newton_method(deriv(g), 1.0); } int main() { std::cout \u0026lt;\u0026lt; minimization([](auto x) { return 2. * square(1. - 4. * x) + square(1. - 2. * x); }) \u0026lt;\u0026lt; std::endl; return 0; } 微分 #\r$$ f(x + \\Delta x) \\approx f(x) + f\u0026rsquo;(x) \\cdot \\Delta x $$\n例如：\n求 \\( 2^{1.4} \\) $$ f(x) = a^x \\Rightarrow f(x + \\Delta x) = a^{x + \\Delta x} \\approx a^{x} + a^{x} ln(a) \\cdot \\Delta x \\\\ 2^{1 + 0.4} \\approx 2 + 2ln(2) \\cdot 0.4 \\approx 2.554518\u0026hellip; $$\n而原表达式 \\( 2^{1.4} = 2.63902\u0026hellip; \\)\n求 \\( 2^{9} \\) 利用公式有 \\( 2^{10 - 1} = (2^{10})^{(1 - \\frac{1}{10})} \\approx 2^{10} + 2^{10} ln(2^{10}) \\cdot 0.1 \\approx 709.783\u0026hellip; \\)\n而 \\(2^9\\) 等于 \\(512\\)\n参考 #\rNewton\u0026rsquo;s method - wikipedia 果壳网 高等数学 ","date":"2018-08-04","externalUrl":null,"permalink":"/docs/2018-08-04-newton-s-method/","section":"Docs","summary":"","title":"牛顿法(Newton's method)","type":"docs"},{"content":"一种区间操作算法。\n算法实现 #\r#include \u0026lt;iostream\u0026gt; #define LC(i) ((i) \u0026lt;\u0026lt; 1) #define RC(i) ((i) \u0026lt;\u0026lt; 1 | 1) #define M 10010 #define min(a, b) ((a) \u0026lt; (b) ? (a) : (b)) struct { int l, r, val; } SegTree[M]; int num[] = { 18, 17, 19, 13, 15, 11, 20 }; void build(int l, int r, int k) { if (l == r) SegTree[k].val = num[l]; else { int m = (l + r) \u0026gt;\u0026gt; 1; build(l, m, LC(k)); build(m + 1, r, RC(k)); SegTree[k].val = min(SegTree[LC(k)].val, SegTree[RC(k)].val); } } void update(int l, int r, int k, int pos, int v) { if (l \u0026gt; pos || r \u0026lt; pos || r \u0026lt; l) return; if (l == r) { SegTree[k].val = v; return; } int m = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= m) update(l, m, LC(k), pos, v); else update(m + 1, r, RC(k), pos, v); SegTree[k].val = min(SegTree[LC(k)].val, SegTree[RC(k)].val); } int query(int l, int r, int x, int y, int k) { if (l \u0026gt; r || l \u0026gt; y || r \u0026lt; x) return M; if (x \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= y) return SegTree[k].val; int m = (l + r) \u0026gt;\u0026gt; 1; return min(query(l, m, x, y, LC(k)), query(m + 1, r, x, y, RC(k))); } int main() { int len, x, y, k, v; len = (sizeof(num) / sizeof(int)) - 1; build(0, len, 1); for (int i = 1; i \u0026lt;= 2 * len; i++) std::cout \u0026lt;\u0026lt; SegTree[i].val \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;查询[x,y]区间的最小值：\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; std::cout \u0026lt;\u0026lt; query(0, len, x, y, 1) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;更新下标k位置上的值：\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; update(0, len, 1, k, v); for (int i = 1; i \u0026lt;= 2 * len; i++) std::cout \u0026lt;\u0026lt; SegTree[i].val \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; return 0; } 模板 #\r#include \u0026lt;bits/stdc++.h\u0026gt; #define MP make_pair #define PB push_back #define st first #define nd second #define rd third #define rg register #define FOR(i, a, b) for(int i =(a); i \u0026lt;=(b); ++i) #define RE(i, n) FOR(i, 1, n) #define FORD(i, a, b) for(int i = (a); i \u0026gt;= (b); --i) #define REP(i, n) for(int i = 0;i \u0026lt;(n); ++i) #define VAR(v, i) __typeof(i) v=(i) #define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i) #define ALL(x) (x).begin(), (x).end() #define SZ(x) ((int)(x).size()) using namespace std; #define l(i) ((i) \u0026lt;\u0026lt; 1) #define r(i) ((i) \u0026lt;\u0026lt; 1 | 1) const int N = 500010; struct { int l, r, val, tag; } segment[N]; inline int read() { char c; int ret = 0, sgn = 1; do{c = getchar();}while((c \u0026lt; \u0026#39;0\u0026#39; || c \u0026gt; \u0026#39;9\u0026#39;) \u0026amp;\u0026amp; c != \u0026#39;-\u0026#39;); if(c == \u0026#39;-\u0026#39;) sgn = -1; else ret = c - \u0026#39;0\u0026#39;; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) ret = ret * 10 + (c - \u0026#39;0\u0026#39;); return sgn * ret; } void build(int num[], int s, int e, int p) { if (s == e) segment[p].val = num[s]; else { segment[p].tag = 0; int m = (s + e) \u0026gt;\u0026gt; 1; build(num, s, m, l(p)); build(num, m + 1, e, r(p)); segment[p].val = segment[l(p)].val + segment[r(p)].val; } } void update(int s, int e, int b, int f, int p, int v) { if (b \u0026lt;= s \u0026amp;\u0026amp; e \u0026lt;= f) { segment[p].val += v*(e - s + 1); segment[p].tag += v; return; } int m = (s + e) \u0026gt;\u0026gt; 1; segment[l(p)].tag += segment[p].tag; segment[l(p)].val += segment[p].tag*(m - s + 1); segment[r(p)].tag += segment[p].tag; segment[r(p)].val += segment[p].tag*(e - m); segment[p].tag = 0; if (b \u0026lt;= m) update(s, m, b, f, l(p), v); if (f \u0026gt; m) update(m + 1, e, b, f, r(p), v); segment[p].val = segment[l(p)].val + segment[r(p)].val; } int query(int s, int e, int b, int f, int p) { if (b \u0026lt;= s \u0026amp;\u0026amp; e \u0026lt;= f) return segment[p].val; int m = (s + e) \u0026gt;\u0026gt; 1, ans = 0; segment[l(p)].tag += segment[p].tag; segment[l(p)].val += segment[p].tag*(m - s + 1); segment[r(p)].tag += segment[p].tag; segment[r(p)].val += segment[p].tag*(e - m); segment[p].tag = 0; if (b \u0026lt;= m) ans += query(s, m, b, f, l(p)); if (f \u0026gt; m) ans += query(m + 1, e, b, f, r(p)); return ans; } int main() { int n, m, num[N], x, y, v, opera; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; num[i]; build(num, 1, n, 1); while (m--) { cin \u0026gt;\u0026gt; opera; switch(opera) { case 1: cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; v; update(1, n, x, y, 1, v); break; case 2: cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; query(1, n, x, y, 1) \u0026lt;\u0026lt; endl; break; } } return 0; } 参考 #\rgithub-consmos\n博客园-TenosDoIt\n","date":"2018-08-01","externalUrl":null,"permalink":"/docs/2018-08-01-segment-tree/","section":"Docs","summary":"","title":"线段树（Segment tree）","type":"docs"},{"content":"树状数组是一种是常用于区间操作的算法。\n算法实现 #\r#include \u0026lt;iostream\u0026gt; #define LSB(i) (i \u0026amp; -i) const int M = 10001; int bit_tree[M]; int freq[M]; int getsum(int index) { int sum = 0; for (index += 1; index \u0026gt; 0; index -= LSB(index)) sum += bit_tree[index]; return sum; } void update(int n, int index, int val) { for (index += 1; index \u0026lt;= n; index += LSB(index)) bit_tree[index] += val; } void init(int freq[], int n) { for (int i = 1; i \u0026lt;= n; i++) bit_tree[i] = 0; for (int i = 0; i \u0026lt; n; i++) update(n, i, freq[i]); } int main() { int n; std::cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) std::cin \u0026gt;\u0026gt; freq[i]; init(freq, n); for (int i = 0; i \u0026lt; n; i++) std::cout \u0026lt;\u0026lt; getsum(i) \u0026lt;\u0026lt; std::endl; for (int i = 1; i \u0026lt;= n; i++) std::cout \u0026lt;\u0026lt; bit_tree[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; return 0; } 模板 #\r#include \u0026lt;bits/stdc++.h\u0026gt; #define MP make_pair #define PB push_back #define st first #define nd second #define rd third #define rg register #define FOR(i, a, b) for(int i =(a); i \u0026lt;=(b); ++i) #define RE(i, n) FOR(i, 1, n) #define FORD(i, a, b) for(int i = (a); i \u0026gt;= (b); --i) #define REP(i, n) for(int i = 0;i \u0026lt;(n); ++i) #define VAR(v, i) __typeof(i) v=(i) #define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i) #define ALL(x) (x).begin(), (x).end() #define SZ(x) ((int)(x).size()) using namespace std; #define lowbit(x) ((x) \u0026amp; (-x)) const int N = 500010; int id[N]; void upd(int n, int k, int x) { while (k \u0026lt;= n) id[k] += x, k += lowbit(k); } void dif(int n, int l, int r, int x) { upd(n, l, x); upd(n, r + 1, -x); } int sum(int k) { int ans = 0; while (k \u0026gt; 0) ans += id[k], k -= lowbit(k); return ans; } int org(int k) { return sum(k) - sum(k - 1); } int ask(int l, int r) { return sum(r) - sum(l - 1); } int main() { int n, m, k, x, opera, l, r, pre; pre = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; FOR (i, 1, n) { cin \u0026gt;\u0026gt; x; upd(n, i, x - pre); // 差分后更新到树状数组 pre = x; } while(m--) { cin \u0026gt;\u0026gt; opera; switch(opera) { case 1: cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; dif(n, l, r, x); break; case 2: cin \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; sum(k) \u0026lt;\u0026lt; endl; break; } } return 0; } 参考 #\rfenwick tree\n","date":"2018-08-01","externalUrl":null,"permalink":"/docs/2018-08-01-fenwick-tree/","section":"Docs","summary":"","title":"树状数组（Fenwick tree）","type":"docs"},{"content":"\rAbout algorithm #\rUnion-Find algorithm(also called a Disjoint-set or Merge find algorithm) is a very useful data structure.\nReferences #\rRecommend to see this document:\rUnion-Find.pdf\nAlgorithm implementation #\rThe C code as follows:\n#include \u0026lt;iostream\u0026gt; const int N = 10010; int id[N]; void init() { for (int i = 0; i \u0026lt; N; i++) id[i] = i; } int find(int r) { while (id[r] != r)\tr = id[r]; return r; } void transplant(int i) // path compression { int r = find(i); while (i != r) { int p = id[i]; id[i] = r; i = p; } } bool issmooth(int p, int q) { return find(p) == find(q); } void join(int p, int q) { int r1 = find(p), r2 = find(q); if (r1 != r2) id[r1] = r2; } int main() { init(); for (int i = 0; i \u0026lt; 8; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; \u0026lt;\u0026lt; id[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; join(1, 2); join(1, 3); join(2, 4); join(5, 6); join(6, 7); join(6, 8); if (issmooth(2, 7)) cout \u0026lt;\u0026lt; \u0026#34;true\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;false\u0026#34; \u0026lt;\u0026lt; endl; transplant(1); for (int i = 0; i \u0026lt; 8; i++) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;-\u0026gt;\u0026#34; \u0026lt;\u0026lt; id[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; getchar(); return 0; } /* 1--2--4 | / |/ 3 5--6--7 | 8 */ ","date":"2018-07-28","externalUrl":null,"permalink":"/docs/2018-07-28-union-find/","section":"Docs","summary":"","title":"并查集","type":"docs"},{"content":"","date":"2018-07-26","externalUrl":null,"permalink":"/tags/matlab/","section":"Tags","summary":"","title":"MatLab","type":"tags"},{"content":"\r梯度下降法(Gradient descent)又叫最速下降法，是一种局部搜索算法，属于智能算法，类似的有爬山算法、模拟退火等。基本原理是优化理论中的无约束问题，利用梯度搜索函数变化最快的方向，然后不断迭代寻找出极值的方法。\n有空我将补上推导过程并给出梯度法的收敛条件，可能还会介绍一些其它无约束问题的优化算法(牛顿法、共轭梯度法等)及其他约束问题的优化算法，届时我们将会看到许多有趣的搜索算法，比如斐波那契法、黄金比例法（\\( 0.618 \\)法）等。\n代码实现 #\r使用方法就是自定义一个多元函数 \\( g \\)，然后如下方式调用：\n(gradient-descent g init-arguments max-iterations tolerance)\n例子： \\( f(x_1, x_2) = exp(x_1^2 + x_2^2) \\)\n(gradient-descent (lambda (vec) (exp (+ (square (list-ref vec 0)) (square (list-ref vec 1))))) (list 1.0 1.0) 30 0.00001) Scheme #\r(define delta 0.00001) (define (deriv g) (lambda (x) (/ (- (g (+ x delta)) (g x)) delta))) (define (newton-transform g) (lambda (x) (- x (/ (g x) ((deriv g) x))))) (define (fixed-point g first-guess) (define (close-enough? v1 v2) (\u0026lt; (abs (- v1 v2)) delta)) (define (try guess) (let ((next (g guess))) (if (close-enough? guess next) guess (try next)))) (try first-guess)) (define (newton-method g guess) (fixed-point (newton-transform g) guess)) (define (minimized g) (newton-method (deriv g) 1.0)) (define (gradient-descent g init-vec max-it tolerance) (define len (- (length init-vec) 1)) (define (partial-derivative g) (lambda (vec index) (let ((d-vec (list-copy vec))) (list-set! d-vec index (+ (list-ref d-vec index) delta)) (/ (- (g d-vec) (g vec)) delta)))) (define (gradient-vector g vec) (define (iter i res) (if (\u0026lt; i 0) res (iter (- i 1) (cons ((partial-derivative g) vec i) res)))) (iter len ())) (define (distance vec) (define (iter i result) (if (\u0026lt; i 0) result (iter (- i 1) (+ result (square (list-ref vec i)))))) (sqrt (iter len 0))) (define (next vec x grad) (define (iter i res) (if (\u0026lt; i 0) res (iter (- i 1) (cons (- (list-ref vec i) (* x (list-ref grad i))) res)))) (iter len ())) (define (x-transform vec x grad) (next vec x grad)) (define (iter vec i) (let ((grad-vec (gradient-vector g vec))) (display vec) (newline) (cond ((\u0026lt; max-it i) vec) ((\u0026lt; (distance grad-vec) tolerance) vec) (else (let ((minimum (minimized (lambda (x) (g (x-transform vec x grad-vec)))))) (iter (next vec minimum grad-vec) (+ i 1))))))) (iter init-vec 0)) C++ #\r#include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;functional\u0026gt; const double h = 1e-5; auto square(double x) -\u0026gt; double const { return x * x; } auto cube(double x) -\u0026gt; double const { return x * x * x; } template\u0026lt;class Fn_Ty\u0026gt; auto partial_derivative(Fn_Ty g) { auto a = [g](const auto\u0026amp; vec, size_t i) { auto components = vec; components[i] += h; return (g(components) - g(vec)) / h; }; return a; } template\u0026lt;class Fn_Ty, class Arg\u0026gt; auto fixed_point(Fn_Ty g, Arg first_guess) { auto close_enough = [](auto v1, auto v2) { return (std::abs(v1 - v2) \u0026lt; 1e-5); }; auto try_again = [g, close_enough](auto guess, auto\u0026amp; try_ref) { auto next = g(guess); if (close_enough(guess, next)) return next; else return try_ref(next, try_ref); }; return try_again(first_guess, try_again); } template\u0026lt;class Fn_Ty\u0026gt; auto deriv(Fn_Ty g) { auto a = [g](auto x) { return (g(x + h) - g(x)) / h; }; return a; } template\u0026lt;class Fn_Ty\u0026gt; auto newton_transform(Fn_Ty g) { auto a = [g](auto x) { return x - (g(x) / deriv(g)(x)); }; return a; } template\u0026lt;class Fn_Ty, class Arg\u0026gt; auto newton_method(Fn_Ty g, Arg guess) { return fixed_point(newton_transform(g), guess); } std::vector\u0026lt;double\u0026gt; operator*(double b, const std::vector\u0026lt;double\u0026gt;\u0026amp; a) { std::vector\u0026lt;double\u0026gt; c(a.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) c[i] = a[i] * b; return c; } std::vector\u0026lt;double\u0026gt; operator*(const std::vector\u0026lt;double\u0026gt;\u0026amp; a, double b) { return b * a; } std::vector\u0026lt;double\u0026gt; operator-(const std::vector\u0026lt;double\u0026gt;\u0026amp; a, double b) { std::vector\u0026lt;double\u0026gt; c(a.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) c[i] = a[i] - b; return c; } std::vector\u0026lt;double\u0026gt; operator-(double b, const std::vector\u0026lt;double\u0026gt;\u0026amp; a) { std::vector\u0026lt;double\u0026gt; c(a.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) c[i] = b - a[i]; return c; } std::vector\u0026lt;double\u0026gt; operator-(const std::vector\u0026lt;double\u0026gt;\u0026amp; a) { std::vector\u0026lt;double\u0026gt; c(a.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) c[i] = -a[i]; return c; } void operator+=(std::vector\u0026lt;double\u0026gt;\u0026amp; a, const std::vector\u0026lt;double\u0026gt;\u0026amp; b) { assert(a.size() == b.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) a[i] += b[i]; } void operator-=(std::vector\u0026lt;double\u0026gt;\u0026amp; a, const std::vector\u0026lt;double\u0026gt;\u0026amp; b) { assert(a.size() == b.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) a[i] -= b[i]; } template\u0026lt;class Goal_FnTy\u0026gt; class GradientDescent { public: GradientDescent(std::function\u0026lt;Goal_FnTy\u0026gt; g, std::vector\u0026lt;double\u0026gt; init_values, const double error, size_t max_iter = 20) : error(error), max_it(max_iter), gradient_components(), init_variable(init_values), vec(init_values), goal_fn(g) { } void run(bool output = true) { size_t step = 0; while (step \u0026lt; max_it) { if (output) step_output(step); std::vector\u0026lt;double\u0026gt; gradient_components; // 梯度向量 for (size_t i = 0; i \u0026lt; vec.size(); i++) gradient_components.push_back(partial_derivative(goal_fn)(vec, i)); if (distance(gradient_components) \u0026lt; error) break; auto fg = [this, gradient_components](auto lambda) { std::vector\u0026lt;double\u0026gt; lambda_components; for (size_t i = 0; i \u0026lt; vec.size(); i++) lambda_components.push_back(vec[i] - lambda * gradient_components[i]); return goal_fn(lambda_components); }; // 使用牛顿法搜索极小点 double min_lambda = minimization(fg); // 极小点 vec -= gradient_components * min_lambda; // 下一步迭代 step += 1; } } std::vector\u0026lt;double\u0026gt;\u0026amp; const run() const { run(false); return vec; } std::vector\u0026lt;double\u0026gt;\u0026amp; const get() const { return vec; } private: void step_output(size_t step) { std::cout \u0026lt;\u0026lt; step \u0026lt;\u0026lt; \u0026#34; : \u0026#34; \u0026lt;\u0026lt; \u0026#34;(\u0026#34;; for (size_t i = 0; i \u0026lt; vec.size(); i++) std::cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; (i + 1 == vec.size() ? \u0026#34;\u0026#34; : \u0026#34;, \u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } double distance(const std::vector\u0026lt;double\u0026gt;\u0026amp; vec) { double sum = 0; for (auto _ : vec) sum += square(_); return std::sqrt(sum); } template\u0026lt;class Fn_Ty\u0026gt; auto minimization(Fn_Ty g) { return newton_method(deriv(g), 1.0); } // 误差 const double error; // 最大迭代次数 size_t max_it; // 初始值 std::vector\u0026lt;double\u0026gt; init_variable; // 最终目标函数极值 std::vector\u0026lt;double\u0026gt; vec; // 目标函数 std::function\u0026lt;Goal_FnTy\u0026gt; goal_fn; }; 测试 #\r$$ min \\ f(\\mathbf{x}) = 2x_1 ^2 + x_2 ^2, \\\\ x_0 = (1, 1)^T, \\epsilon = \\frac{1}{100000} $$\n问题最优解：(0, 0)\n该函数的样子：\nScheme：\n(gradient-descent (lambda (vec) (+ (* 2 (square (list-ref vec 0))) (square (list-ref vec 1)))) (list 1.0 1.0) 20 0.00001) 输出：\n(1. 1.)\r(-.11109809785453906 .44445095107273047)\r(.07406415148073814 .0740568166924851)\r(-8.226060108502659e-3 3.2915785342297756e-2)\r(5.479613029965878e-3 5.473976292833832e-3)\r(-6.076458754474259e-4 2.4334748892817517e-3)\r(3.998023673891758e-4 3.952652685951883e-4)\r(-4.351939188329914e-5 1.760888045421857e-4)\r(2.3048444806604486e-5 1.9613203841429633e-5)\r(-1.9005725715702401e-6 8.666514023037452e-6)\r(-4.13145223743898e-6 3.7481300728847094e-6)\r(-4.519310966043615e-6 1.7948473900002134e-6)\r(-4.58949997889981e-6 1.2987640626074323e-6)\r(-4.602395677437769e-6 1.1998274507463487e-6)\r(-4.604772161673363e-6 1.1812992414638758e-6)\r(-4.605206860686667e-6 1.1778999304581313e-6)\r(-4.605288702309115e-6 1.1772595832695892e-6)\r(-4.605301020582233e-6 1.1771631923490466e-6)\r(-4.6053101069904185e-6 1.1770920897757949e-6)\r(-4.605310439480507e-6 1.1770894879586069e-6)\r(-4.6053066942518565e-6 1.177118795311575e-6)\r(-4.605302200151839e-6 1.1771539626038494e-6)\r;Value: (-4.605302200151839e-6 1.1771539626038494e-6) C++：\nint main() { auto my_func = [](const auto\u0026amp; x) { return 2. * square(x[0]) + square(x[1]); }; GradientDescent\u0026lt;double(const std::vector\u0026lt;double\u0026gt;\u0026amp;)\u0026gt; gd = GradientDescent\u0026lt;double(const std::vector\u0026lt;double\u0026gt;\u0026amp;)\u0026gt;(my_func, {1.0, 1.0}, 1e-5); gd.run(); return 0; } 输出：\n0 : (1, 1)\r1 : (-0.111091, 0.444454)\r2 : (0.074063, 0.0740505)\r3 : (-0.00822527, 0.0329133)\r4 : (0.00547914, 0.00547344)\r5 : (-0.000607558, 0.00243326)\r6 : (0.000399758, 0.0003952)\r7 : (-4.35106e-05, 0.000176061)\r8 : (2.30431e-05, 1.9607e-05)\r9 : (-1.89989e-06, 8.6636e-06)\r10 : (-4.13021e-06, 3.74858e-06)\r11 : (-4.51828e-06, 1.79693e-06)\r12 : (-4.58859e-06, 1.3009e-06)\r13 : (-4.60152e-06, 1.20187e-06)\r14 : (-4.60391e-06, 1.18329e-06)\r15 : (-4.60435e-06, 1.17985e-06)\r16 : (-4.60443e-06, 1.17921e-06)\r17 : (-4.60445e-06, 1.17909e-06)\r18 : (-4.60445e-06, 1.17907e-06)\r19 : (-4.60445e-06, 1.17907e-06) 其它语言实现 #\rMatlab #\rclc;clear; figure f = @(x,y) 3*(1-x).^2.*exp(-(x.^2) - (y+1).^2) ... - 10*(x/5 - x.^3 - y.^5).*exp(-x.^2-y.^2) ... - 1/3*exp(-(x+1).^2 - y.^2); tolerance = 1e-5; max_iter = 30; x0 = 0.; y0 = 1.5; x = -2.8:0.001:2.8; y = x\u0026#39;; X = -2.8:0.05:2.8; set(gcf, \u0026#39;Position\u0026#39;, get(0,\u0026#39;Screensize\u0026#39;)); surf(X,X,f(X, X\u0026#39;)); xlabel(\u0026#39;x\u0026#39;);ylabel(\u0026#39;y\u0026#39;);zlabel(\u0026#39;z\u0026#39;); [gx,gy] = gradient(f(x, y), 0.1); hold on filename = \u0026#39;d:/blog/img/gradient_descent_visualization.gif\u0026#39;; for i=0:1:max_iter % syms x y % g = gradient(f, [x, y]); % g1 = subs(g(1), [x, y], {x0, y0}); % g2 = subs(g(2), [x, y], {x0, y0}); % d = -[g1 g2]; t = find(((x \u0026lt; x0 + 1e-3) \u0026amp; (x \u0026gt; x0 - 1e-3)) \u0026amp; ((y \u0026lt; y0 + 1e-3) \u0026amp; (y \u0026gt; y0 - 1e-3))); d = [gx(t), gy(t)]; disp(d) if isempty(d) break; elseif(sqrt(d * d\u0026#39;) \u0026lt; tolerance) break; end plot3(x0,y0,f(x0, y0),\u0026#39;r*\u0026#39;); lambda = fminbnd(@(c) f(x0 - c*d(1), y0 - c*d(2)), -5, 5); x0 = x0 - lambda*d(1); y0 = y0 - lambda*d(2); drawnow frame = getframe(gcf); im = frame2im(frame); [imind,cm] = rgb2ind(im,256); if i == 0 imwrite(imind,cm,filename,\u0026#39;gif\u0026#39;, \u0026#39;Loopcount\u0026#39;,inf); else imwrite(imind,cm,filename,\u0026#39;gif\u0026#39;,\u0026#39;WriteMode\u0026#39;,\u0026#39;append\u0026#39;); end end 输出： 以下部分是以前写的，暂时没更新。\nPython #\rsquare = lambda x: x ** 2 side = lambda a, b: (a ** 2 + b ** 2) ** (1 / 2) def d(x_1, x_2): return -4 * x_1, -2 * x_2 def evaluate(x_1, x_2, a, b): return -(2 * a * x_1 + b * x_2) / (2 * square(a) + square(b)) def gradient_descent(x_1, x_2, epsilon, max_iters): iters = 0 a, b = 1, 1 while (side(a, b) \u0026gt; epsilon) \u0026amp; (iters \u0026lt; max_iters): print(\u0026#39;%d (%.6f, %.6f)\u0026#39; % (iters + 1, x_1, x_2)) a, b = d(x_1, x_2) gamma = evaluate(x_1, x_2, a, b) (x_1, x_2) = (x_1 + a * gamma, x_2 + b * gamma) iters += 1 if __name__ == \u0026#39;__main__\u0026#39;: gradient_descent(1, 1, 0.001, 100) 输出:\n1 (1.000000, 1.000000)\r2 (-0.111111, 0.444444)\r3 (0.074074, 0.074074)\r4 (-0.008230, 0.032922)\r5 (0.005487, 0.005487)\r6 (-0.000610, 0.002439)\r7 (0.000406, 0.000406)\r8 (-0.000045, 0.000181) 参考文献 #\r最优化理论与算法 第二版・陈宝林 Gradient descent - wikipedia ","date":"2018-07-26","externalUrl":null,"permalink":"/docs/2018-07-26-gradient-descent/","section":"Docs","summary":"","title":"梯度下降算法（更新于 2020/12/04）","type":"docs"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/ja/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/ja/","section":"Pacyu","summary":"","title":"Pacyu","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/ja/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/ja/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]